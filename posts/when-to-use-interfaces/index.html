<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#282A36"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><title>When to use interfaces - mnavarro.dev</title><meta name=description content="A rant about using and thus, abusing, interfaces for everything"><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"mnavarro.dev","url":"https:\/\/mnavarro.dev\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"https:\/\/mnavarro.dev\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/mnavarro.dev\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"https:\/\/mnavarro.dev\/posts\/when-to-use-interfaces\/","name":"When to use interfaces"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":""},"headline":"When to use interfaces","description":"Not long ago some of my CI pipelines failed in its psalm step. The error was due to an exception that could not be caught, because it was not an exception class. The culprit, the 1.1.1 version of psr\/container, had removed extends Throwable from the Psr\/Container\/ContainerExceptionInterface. Here is the related issue.\nNow, this was all done to a language support issue, which is understandable. But this exposed a somewhat related issue.","inLanguage":"en","wordCount":907,"datePublished":"2021-06-07T00:00:00","dateModified":"2021-06-07T00:00:00","image":"https:\/\/mnavarro.dev\/","keywords":["oop, php, design"],"mainEntityOfPage":"https:\/\/mnavarro.dev\/posts\/when-to-use-interfaces\/","publisher":{"@type":"Organization","name":"https:\/\/mnavarro.dev\/","logo":{"@type":"ImageObject","url":"https:\/\/mnavarro.dev\/","height":60,"width":60}}}</script><meta property="og:title" content="When to use interfaces"><meta property="og:description" content="A rant about using and thus, abusing, interfaces for everything"><meta property="og:url" content="https://mnavarro.dev/posts/when-to-use-interfaces/"><meta property="og:type" content="website"><meta property="og:site_name" content="mnavarro.dev"><meta name=twitter:title content="When to use interfaces"><meta name=twitter:description content="A rant about using and thus, abusing, interfaces for everything"><meta name=twitter:card content="summary"><meta name=generator content="Hugo 0.71.0"><link rel=alternate href=https://mnavarro.dev/index.xml type=application/rss+xml title=mnavarro.dev><link rel=stylesheet href=https://mnavarro.dev/css/style.css><link rel=preload href="https://fonts.googleapis.com/css?family=PT+Mono&display=swap" as=style onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel=stylesheet href="https://fonts.googleapis.com/css?family=PT+Mono&display=swap"></noscript><link rel=preload href=https://mnavarro.dev/css/syntax.css as=style onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://mnavarro.dev/css/syntax.css></noscript><script async defer data-domain=mnavarro.dev src=https://mnavarro.dev/stats.js></script></head><body><header><div class=wrapper><p class="site-brand muted lambda terminal"><a href=https://mnavarro.dev/>mnavarro.dev</a></p><nav><ul><li><a title=Blog href=/>Blog</a></li><li><a title=About href=/about>About</a></li><li><a title=Media href=/media>Media</a></li><li><a title="Atom Feed" href=/index.xml>Rss</a></li></ul></nav></div></header><main><div class=wrapper><article><h1 class=post-title>When to use interfaces</h1><p class=small>7 June 2021
| 5 minutes read
| 907 words</p><div class=content><p>Not long ago some of my CI pipelines failed in its psalm step. The error was due to an exception that could not be caught, because it was not an exception class. The culprit, the <code>1.1.1</code> version of <code>psr/container</code>, had removed <code>extends Throwable</code> from the <code>Psr/Container/ContainerExceptionInterface</code>. <a href=https://github.com/php-fig/container/issues/33>Here is the related issue</a>.</p><p>Now, this was all done to a language support issue, which is understandable. But this exposed a somewhat related issue. This would have never happened if the PSR had been designed well from the ground up. For me, part of that bad designed involves the famous and wide-spread use of the so called <strong>error marker interfaces</strong>.</p><p>I&rsquo;m writing this piece not because I want <code>psr/container</code> to change, but because I want to raise awareness of this bad practice and eventually convince people writing new library code or refactoring existing library code to dump this approach.</p><h2 id=the-value-of-interfaces>The Value of Interfaces</h2><p>Interfaces are probably the building blocks that make object oriented programming one of the best programming paradigms out there. Interfaces are there to <strong>abstract routines</strong> and allowing us to swap different implementations of those routines without even touching client code. That&rsquo;s the power that makes modularity work in object oriented programming. You can replace entire subsystems hidden behind an interface without affecting anything.</p><p>The PHP FIG has done tremendous effort on taking some of the most common routines or use cases in PHP and abstract them into interfaces that can be adopted by third party libraries. The purpose of this is to maximize interoperability: if two or more libraries share the same contract or interface, then it is trivial to swap one for another, or even better, building entire subsystems or libraries typing to the interface instead of an implementation means a higher adoption rate.</p><h2 id=the-misuse-of-interfaces>The Misuse of Interfaces</h2><p>Of course, interfaces can be used poorly. If an interface requires us to change client code upon switching implementation, then it becomes what is known as a <em>leaky abstraction</em>. If you have to change client code when swapping implementations, then it means the interface leaks implementation details that client code should not be aware of. This is one of the most common issues interfaces have.</p><p>Another problem, not so much considered, is making <strong>everything</strong> an interface thinking that by doing so we are providing interoperability. Good object oriented practices dictate that interfaces <strong>should</strong> only be used when (1) we are dealing with service classes and/or (2) we will have two or more possible implementations. By services classes I mean classes that <strong>do</strong> something instead of <strong>representing</strong> something (like value objects or models).</p><p>For example, there is little to no value in using interfaces for a value object, unless there are two possible implementations of it. This is the case with the <code>DateTimeInterface</code> in PHP. It has an interface because PHP has both a mutable and an immutable implementation. <code>brick/date-time</code> is only immutable, so no interface is required.</p><p>But other libraries don&rsquo;t get this right. PSR-7 should have been a concrete implementation. This is because literally there is only one possible implementation of it due to the spec being so rigid and opinionated. This would have made adoption much more easier and widespread, eliminate the need for factories and bring so much more benefits to the table.</p><p>FIG members usually answer to this by saying that <a href=https://github.com/php-fig/container/issues/33#issuecomment-849548872>&ldquo;FIG creates interfaces and recommendations&rdquo;</a>, which is a terrible answer. The the mission of FIG is not making interfaces: the mission is to drive interoperability forward in the PHP ecosystem. They do that by means of interfaces and recommendations, but it is not and should not be the only way. <a href=https://groups.google.com/g/php-fig/c/u2Nmovw_Rlc/m/l8Y_MhIEMgAJ>Some members understand this very well</a>, and others don&rsquo;t.</p><p>The <em>interface only</em> approach leads to confusion and using interfaces wrongly. One of these uses is using them as error markers, because the assumption is that extending means implementing.And this leads us to the final issue.</p><h2 id=the-fear-of-inheritance>The Fear of Inheritance</h2><p><strong>Inheritance is evil</strong> is a common aphorism in Object Oriented world. And with right reason: inheritance couples things, makes changing code harder and could lead to an increase of unexpected breaking changes, because the <em>not-so-private</em> api can still be used by other client code.</p><p>We all know that the alternative is use of composition. And there is abundant literature, talks and courses that taught it well. No need to repeat common knowledge here.</p><p>What I currently see now in the professional PHP ecosystem is not so much now an abuse of inheritance, but a fear of it. We have gone to the other end of the spectrum.</p><p>Part of being a good software engineer is to be able to determine when to use some tool or pattern and when not, based on an informed decision and consideration of the possible future implications.</p><p>Using concrete classes for errors in libraries that only contain interfaces is a perfectly reasonable approach. It must be taken with a grain of salt though: implementing custom logic in the exception class is discouraged, because is then when inheritance starts to become a potential issue. On the other side, using interfaces solves no problem at all. What it does is that it creates more work and/or potential confusion for implementors.</p><p>So here it is, my rant. Oh, and one more thing. For the love of Pete, stop suffixing your interface names with the word <code>Interface</code>. It is useless and repetitive. You don&rsquo;t name your classes <code>QueueClass</code>. Why do it with interfaces?</p></div><div class=post-terms><p class=small>Taggged
<a href=https://mnavarro.dev/tags/oop/>oop</a>,
<a href=https://mnavarro.dev/tags/php/>php</a>,
<a href=https://mnavarro.dev/tags/design/>design</a>,</p></div><div class=post-nav><div class=post-nav-prev><a href=https://mnavarro.dev/posts/tenant-pollution/>Preventing tenant pollution in multitenant applications</a></div><div class=post-nav-next><a href=https://mnavarro.dev/posts/job-hunting-realizations/>Job Hunting Realizations</a></div></div></article><div class=comments><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"mnavarro"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></main><footer><div class=wrapper><p class=small>Last Modified:
2 July 2021</p><p class="muted lambda">Process exited with code <span id=status>0</span></p></div></footer></body></html>