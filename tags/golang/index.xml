<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Golang on The Chilean Nerd</title><link>https://blog.mnavarro.dev/tags/golang/</link><description>Recent content in Golang on The Chilean Nerd</description><generator>Hugo -- gohugo.io</generator><language>en-GB</language><copyright>Â©2019 Matias Navarro Carter. CC-BY-SA.</copyright><lastBuildDate>Wed, 08 Sep 2021 20:00:00 +0100</lastBuildDate><atom:link href="https://blog.mnavarro.dev/tags/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>Testing HTTP SDKs in Golang</title><link>https://blog.mnavarro.dev/posts/http-sdk-testing-in-go/</link><pubDate>Wed, 08 Sep 2021 20:00:00 +0100</pubDate><guid>https://blog.mnavarro.dev/posts/http-sdk-testing-in-go/</guid><description>How do you test code that integrates with a third party HTTP service?
The Philosophical Answer If you think about it, it is not an easy question to answer. Maybe you have already some strong opinions formed about it. But, in my experience, answers to this question differ greatly among developers, even between seasoned ones.
I believe those differences are due to some preconceived ideas or different definitions about what testing is.</description><content>&lt;p>How do you test code that integrates with a third party HTTP service?&lt;/p>
&lt;h1 id="the-philosophical-answer">The Philosophical Answer&lt;/h1>
&lt;p>If you think about it, it is not an easy question to answer. Maybe you have already some strong opinions formed about it. But, in my experience, answers to this question differ greatly among developers, even between seasoned ones.&lt;/p>
&lt;p>I believe those differences are due to some preconceived ideas or different definitions about what testing is. For example, some people believe that testing is making sure your code works. The problem with that definition is that it is too vague; &amp;ldquo;it works&amp;rdquo; can mean anything.&lt;/p>
&lt;figure class="left" >
&lt;img src="https://blog.sergeyev.info/images/works-on-my-machine/the-line.jpg" />
&lt;/figure>
&lt;p>Take, for instance, the following (too familiar) situation: you are told to code a service (or SDK) that integrates with a third party api or http service. As is usual with integrations, confusing or incomplete specs are passed around. Nonetheless, that is sufficient to do your job. You decide to test creating a mock server based on the spec and build your suite to a very good coverage. So far so good.&lt;/p>
&lt;p>But, when the day comes to do some acceptance testing against the QA environment of the service you are integrating to, you realized nothing worked. Turns out services needed an extra header that was not included in any spec. No problem though; you add it to the code, update your tests and move forward.&lt;/p>
&lt;p>I&amp;rsquo;ll come back to this story to explore other relevant topics later. For now, I want to use it to ask you a question. Would you say that the initial version released to test against QA &amp;ldquo;worked&amp;rdquo;? Well, it&amp;rsquo;s a tricky one, isn&amp;rsquo;t it? It did not worked in the sense that it did not integrate correctly because of the missing header. It worked in the sense that the program did what it was coded to do with the available knowledge at the time.&lt;/p>
&lt;p>Based on this, I would like to make the main point of this article, from which every other point flows. &lt;strong>Testing is not making sure your program does something correctly; testing is making sure your program does what the code says it does.&lt;/strong> In our previously mentioned story, we cannot ensure a correct integration until we have hit a real service (and not a mock), but we can have good tests that ensure the program is doing what we have coded it to do.&lt;/p>
&lt;p>I think the distinction of these two is greatly accentuated in integrations with third party http services. Unless you have an spec that is automatically generated from the service code, until you start hitting endpoints, you can never know for sure if you have integrated correctly or not.&lt;/p>
&lt;p>In my opinion, the sooner we embrace this reality, the better. Once we do, we will be able to go and ask ourselves the next question.&lt;/p>
&lt;h2 id="what-then-do-we-test">What then do we test?&lt;/h2>
&lt;p>So, if we cannot test that our SDK integrates correctly with the service. What do we test then? The answer is: &lt;strong>we test that our code follows what we understand of the specification we were given.&lt;/strong>&lt;/p>
&lt;p>For instance, if the specification says that we should send an &lt;code>Authorization&lt;/code> header with some sort of token, we test that (1) A request is created containing the &lt;code>Authorization&lt;/code> header and (2) that the passed token value is indeed the same that is injected in the header. Similar principles follow for URL, method and body.&lt;/p>
&lt;p>The following of a specification does not have only to do with the expectations about a request, but also with the correct handling of a response. This means we should also test that our code follows the specification when handling responses.&lt;/p>
&lt;p>We should map status codes to certain errors, or react to different content types, or deserialize certain payloads to some types without data loss, etc. We should test that our code does this based on the spec.&lt;/p>
&lt;p>Okay, I&amp;rsquo;m sure you are getting very impatient and want to get to the &amp;ldquo;how&amp;rdquo; of testing a third party http integration. Just allow me to say one more thing.&lt;/p>
&lt;h2 id="what-are-we-not-testing">What are we not testing?&lt;/h2>
&lt;p>Many developers understand all that I&amp;rsquo;ve written. So, they take their keyboards and decide that the best way to test the aforementioned things is just by spinning up a temporary web server process, listening in a random port, that is pre-configured to respond to requests mapping certain methods and urls to certain responses. Most people call this a &lt;em>mock server&lt;/em>.&lt;/p>
&lt;p>No blame on them! I&amp;rsquo;ve seen this approach being endorsed by &lt;a href="https://youtu.be/rWBSMsLG8po?t=2413">really prominent Go developers&lt;/a>. And I think it is specially prominent in Go due to the fact that it is indeed very easy to spin up a server in a separate Goroutine.&lt;/p>
&lt;p>However, this approach is often unnecessary and overly complex. Let me explain why.&lt;/p>
&lt;h3 id="we-are-not-testing-tcptlshttp">We are not testing TCP/TLS/HTTP!&lt;/h3>
&lt;p>First, there is no need to send our &lt;code>*http.Request&lt;/code> over a TCP socket to a server, have the server parse the request and end up with a &lt;code>*http.Request&lt;/code> again in a completely different process, that then will be passed to a handler that will match our request and return a response.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-txt" data-lang="txt">http.Request --&amp;gt; Http Client --&amp;gt; TCP Socket --&amp;gt; Server --&amp;gt; Http Parser --&amp;gt; http.Request --&amp;gt; handler -&amp;gt; http.Response
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We can simplify this massively, bypassing all the TCP, server stuff and just doing things in memory, for instance, in a function.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-txt" data-lang="txt">http.Request -&amp;gt; function -&amp;gt; http.Response
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And this is fine, because we are not testing TCP, nor TLS, nor the HTTP protocol. The Go standard library already has tests for all those packages and functions. We want to test &lt;em>our&lt;/em> code.&lt;/p>
&lt;p>In order for us to test that our code complies to a spec, there is no need then to spin up a web server.&lt;/p>
&lt;p>Plus, if something happens with that server, it will be really hard to debug.&lt;/p>
&lt;h3 id="we-are-not-testing-routing">We are not testing routing!&lt;/h3>
&lt;p>Even when not using server-over-TCP mocking techniques, but in-memory ones, some people still go with building some kind of in-memory testing &amp;ldquo;server&amp;rdquo; that returns responses based on some matching logic. Usually this takes the form of matching the method and the url.&lt;/p>
&lt;p>Again, this is completely unnecessary, and it could lead to undesirable side-effects in testing, plus a couple of more issues.&lt;/p>
&lt;p>It is unnecessary because, remember, we are testing that our code conforms to a spec. In other words, we are testing that we send a request with the correct contents and that we are capable to handle certain responses. We are not testing routing (that a request with a certain method and URL with gives us a certain response).&lt;/p>
&lt;p>This approach usually leads to side effects. Since this massive, respond-to-everything, in-memory mock of a server needs to be configured somewhere, it usually is outside the tested code. If someone changes an id, or accidentally creates another request with the same url there is potential breakage.&lt;/p>
&lt;p>Also, there is no clear contract regarding to what should be the response when a request of this mock cannot be matched. This usually weakens error handling code.&lt;/p>
&lt;p>Finally, a mock like this ignores the fact that some HTTP operations are not idempotent: the same method and url combination can and will give different answers based on the internal state of the server at the time of the call. It is really hard to mock that using this approach.&lt;/p>
&lt;p>It&amp;rsquo;s better not to try to play any matching games and do something deterministic and straightforward.&lt;/p>
&lt;h1 id="the-practical-answer">The Practical Answer&lt;/h1>
&lt;p>Now that I have ranted enough about these things, is time I explain my proposed approach.&lt;/p>
&lt;p>Let&amp;rsquo;s suppose that we have an third party service with an endpoint &lt;code>POST /input&lt;/code>. This endpoint takes a &lt;code>application/json&lt;/code> payload that only contains
one key &lt;code>message&lt;/code>, and can be an string of any length.&lt;/p>
&lt;p>The service returns an &lt;code>application/json&lt;/code> payload with the same structure: again, the object with a &lt;code>message&lt;/code> key.&lt;/p>
&lt;p>This is how I would implement it in Go. Read the comments so you get a better understanding.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">fakesdk&lt;/span>
&lt;span style="color:#75715e">// A main client struct to hold everything together
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">FakeApiClient&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#a6e22e">client&lt;/span> &lt;span style="color:#a6e22e">HTTPClient&lt;/span>
&lt;span style="color:#a6e22e">baseUrl&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
}
&lt;span style="color:#75715e">// A constructor to make that client with good defaults
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">NewFakeApiClient&lt;/span>(&lt;span style="color:#a6e22e">baseUrl&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">FakeApiClient&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">FakeApiClient&lt;/span>{
&lt;span style="color:#a6e22e">client&lt;/span>: &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">DefaultClient&lt;/span>,
&lt;span style="color:#a6e22e">baseUrl&lt;/span>: &lt;span style="color:#a6e22e">baseUrl&lt;/span>
}
}
&lt;span style="color:#75715e">// Some people like to make an interface with the same signature
&lt;/span>&lt;span style="color:#75715e">// as http.Client.Do function so they can swap implementations for
&lt;/span>&lt;span style="color:#75715e">// testing. http.RoundTripper can do this already, but well,
&lt;/span>&lt;span style="color:#75715e">// everyone has their own preference.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">HTTPClient&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;span style="color:#a6e22e">Do&lt;/span>(&lt;span style="color:#a6e22e">req&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">Request&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">Response&lt;/span>, &lt;span style="color:#66d9ef">error&lt;/span>)
}
&lt;span style="color:#75715e">// This creates the request. Pretty standard stuff here.
&lt;/span>&lt;span style="color:#75715e">// The only detail is that we need to serialize from json and make
&lt;/span>&lt;span style="color:#75715e">// sure we put the right content type.
&lt;/span>&lt;span style="color:#75715e">// Oh, and that we pass the context to the request!
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">cl&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">FakeApiClient&lt;/span>) &lt;span style="color:#a6e22e">mustMakeRequest&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span> &lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#a6e22e">method&lt;/span>, &lt;span style="color:#a6e22e">path&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">input&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span>{}) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">Request&lt;/span> {
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">body&lt;/span> &lt;span style="color:#a6e22e">io&lt;/span>.&lt;span style="color:#a6e22e">Reader&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">input&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#a6e22e">b&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">json&lt;/span>.&lt;span style="color:#a6e22e">Marshal&lt;/span>(&lt;span style="color:#a6e22e">input&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
panic(&lt;span style="color:#a6e22e">err&lt;/span>) &lt;span style="color:#75715e">// Developer error
&lt;/span>&lt;span style="color:#75715e">&lt;/span> }
&lt;span style="color:#a6e22e">body&lt;/span> = &lt;span style="color:#a6e22e">bytes&lt;/span>.&lt;span style="color:#a6e22e">NewBuffer&lt;/span>(&lt;span style="color:#a6e22e">b&lt;/span>)
}
&lt;span style="color:#a6e22e">url&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">cl&lt;/span>.&lt;span style="color:#a6e22e">baseUrl&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">path&lt;/span>
&lt;span style="color:#a6e22e">req&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">NewRequest&lt;/span>(&lt;span style="color:#a6e22e">method&lt;/span>, &lt;span style="color:#a6e22e">url&lt;/span>, &lt;span style="color:#a6e22e">body&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
panic(&lt;span style="color:#a6e22e">err&lt;/span>) &lt;span style="color:#75715e">// Developer error
&lt;/span>&lt;span style="color:#75715e">&lt;/span> }
&lt;span style="color:#a6e22e">req&lt;/span>.&lt;span style="color:#a6e22e">Header&lt;/span>.&lt;span style="color:#a6e22e">Add&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Content-Type&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;application/json&amp;#34;&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">req&lt;/span>.&lt;span style="color:#a6e22e">WithContext&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span>)
}
&lt;span style="color:#75715e">// The fake input struct
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">FakeInput&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#a6e22e">Message&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;message&amp;#34;`&lt;/span>
}
&lt;span style="color:#75715e">// The fake output struct
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">FakeOutput&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#a6e22e">Message&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;message&amp;#34;`&lt;/span>
}
&lt;span style="color:#75715e">// This is the actual method that will be used in client code.
&lt;/span>&lt;span style="color:#75715e">// Pretty standard stuff too. Sends the request and handles any error.
&lt;/span>&lt;span style="color:#75715e">// Also decodes the payload.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">cl&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">FakeApiClient&lt;/span>) &lt;span style="color:#a6e22e">PostInput&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span> &lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#a6e22e">input&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">FakeInput&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">FakeOutput&lt;/span>, &lt;span style="color:#66d9ef">error&lt;/span>) {
&lt;span style="color:#a6e22e">req&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">cl&lt;/span>.&lt;span style="color:#a6e22e">mustMakeRequest&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;POST&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;/input&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">input&lt;/span>)
&lt;span style="color:#a6e22e">res&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">cl&lt;/span>.&lt;span style="color:#a6e22e">client&lt;/span>.&lt;span style="color:#a6e22e">Do&lt;/span>(&lt;span style="color:#a6e22e">req&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>
}
&lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#a6e22e">res&lt;/span>.&lt;span style="color:#a6e22e">Body&lt;/span>.&lt;span style="color:#a6e22e">Close&lt;/span>()
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">res&lt;/span>.&lt;span style="color:#a6e22e">StatusCode&lt;/span> &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">400&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>, &lt;span style="color:#a6e22e">errors&lt;/span>.&lt;span style="color:#a6e22e">New&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;server responded with code %d&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">res&lt;/span>.&lt;span style="color:#a6e22e">StatusCode&lt;/span>)
}
&lt;span style="color:#a6e22e">out&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">FakeOutput&lt;/span>{}
&lt;span style="color:#a6e22e">err&lt;/span> = &lt;span style="color:#a6e22e">json&lt;/span>.&lt;span style="color:#a6e22e">NewDecoder&lt;/span>(&lt;span style="color:#a6e22e">res&lt;/span>.&lt;span style="color:#a6e22e">Body&lt;/span>).&lt;span style="color:#a6e22e">Decode&lt;/span>(&lt;span style="color:#a6e22e">out&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">out&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now, the only thing I need to test is that I send the correct request and I&amp;rsquo;m capable to handle all possible responses or eventual socket errors. That&amp;rsquo;s it. Nothing else.&lt;/p>
&lt;p>Sending the the correct request in this case means that the method is correct, the url too, that the body gets serialized to json correctly and that the compulsory headers are present and with the correct values.&lt;/p>
&lt;p>Being capable to handle all possible responses means that I should code expectations for when my code fails. For instance, if I get a response with a status code 400, then my code should return an error saying &amp;ldquo;server responded with code 400&amp;rdquo;.&lt;/p>
&lt;p>Now, doing all these checks on the request and building all the responses for every test case would be very verbose. Luckily, I&amp;rsquo;ve created a package just for that. It is called &lt;code>httpclientmock&lt;/code>. It is extremely simple and straight forward, and you are meant to use it in your test suites like this:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">fakesdk_test&lt;/span>
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">postInputTests&lt;/span> = []&lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;span style="color:#a6e22e">input&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">FakeInput&lt;/span>
&lt;span style="color:#a6e22e">mock&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">httpclientmock&lt;/span>.&lt;span style="color:#a6e22e">Mock&lt;/span>
&lt;span style="color:#a6e22e">assertions&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>, &lt;span style="color:#a6e22e">output&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">FakeOutput&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#66d9ef">error&lt;/span>)
}{
{
&lt;span style="color:#a6e22e">name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;test one&amp;#34;&lt;/span>,
&lt;span style="color:#a6e22e">input&lt;/span>: &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">FakeInput&lt;/span>{&lt;span style="color:#e6db74">&amp;#34;This is a message sent&amp;#34;&lt;/span>},
&lt;span style="color:#a6e22e">mock&lt;/span>: &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">httpclientmock&lt;/span>.&lt;span style="color:#a6e22e">Mock&lt;/span>{
&lt;span style="color:#a6e22e">Expect&lt;/span>: &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">httpclientmock&lt;/span>.&lt;span style="color:#a6e22e">Request&lt;/span>{
&lt;span style="color:#a6e22e">Method&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;POST&amp;#34;&lt;/span>,
&lt;span style="color:#a6e22e">Url&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;https://some.fake.service/input&amp;#34;&lt;/span>,
&lt;span style="color:#a6e22e">Headers&lt;/span>: &lt;span style="color:#66d9ef">map&lt;/span>[&lt;span style="color:#66d9ef">string&lt;/span>]&lt;span style="color:#66d9ef">string&lt;/span>{
&lt;span style="color:#e6db74">&amp;#34;Content-Type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;application/json&amp;#34;&lt;/span>,
},
&lt;span style="color:#a6e22e">Body&lt;/span>: []byte(&lt;span style="color:#e6db74">`{&amp;#34;message&amp;#34;:&amp;#34;This is a message sent&amp;#34;}`&lt;/span>),
},
&lt;span style="color:#a6e22e">Return&lt;/span>: &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">httpclientmock&lt;/span>.&lt;span style="color:#a6e22e">Response&lt;/span>{
&lt;span style="color:#a6e22e">StatusCode&lt;/span>: &lt;span style="color:#ae81ff">200&lt;/span>,
&lt;span style="color:#a6e22e">Headers&lt;/span>: &lt;span style="color:#66d9ef">map&lt;/span>[&lt;span style="color:#66d9ef">string&lt;/span>]&lt;span style="color:#66d9ef">string&lt;/span>{
&lt;span style="color:#e6db74">&amp;#34;Content-Type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;application/json&amp;#34;&lt;/span>,
},
&lt;span style="color:#a6e22e">Body&lt;/span>: []byte(&lt;span style="color:#e6db74">`{&amp;#34;message&amp;#34;:&amp;#34;This is a message received&amp;#34;}`&lt;/span>),
},
},
&lt;span style="color:#a6e22e">assertions&lt;/span>: &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>, &lt;span style="color:#a6e22e">output&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">FakeOutput&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#66d9ef">error&lt;/span>) {
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">output&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Error&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;no output&amp;#34;&lt;/span>)
}
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Error&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;an error has happened&amp;#34;&lt;/span>)
}
},
},
}
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">TestPostInput&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>) {
&lt;span style="color:#a6e22e">client&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">FakeApiClient&lt;/span>{&lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">DefaultClient&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;https://some.fake.service&amp;#34;&lt;/span>}
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">test&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">postInputTests&lt;/span> {
&lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Run&lt;/span>(&lt;span style="color:#a6e22e">test&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span>, &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>) {
&lt;span style="color:#75715e">// Inject in client mutates http.DefaultClient transport.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// The restore function restores the previous transport.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">restore&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span>.&lt;span style="color:#a6e22e">mock&lt;/span>.&lt;span style="color:#a6e22e">InjectInClient&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>)
&lt;span style="color:#75715e">// We defer the restoring of the previous transport when the test finishes
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#a6e22e">restore&lt;/span>()
&lt;span style="color:#75715e">// Pass the input
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">out&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">client&lt;/span>.&lt;span style="color:#a6e22e">PostInput&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Background&lt;/span>(), &lt;span style="color:#a6e22e">test&lt;/span>.&lt;span style="color:#a6e22e">input&lt;/span>)
&lt;span style="color:#75715e">// Assert about the output
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span>.&lt;span style="color:#a6e22e">assertions&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span>, &lt;span style="color:#a6e22e">out&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
})
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The benefits of using this library are huge. First, its ability to modify &lt;code>http.DefaultClient&lt;/code> responsibly means you don&amp;rsquo;t need to worry about dependency injection too much when setting up tests that send requests very deep in the call stack. So, you could use it for E2E tests without a problem.&lt;/p>
&lt;p>If you wish to use better practices like dependency injection, no problem, we got you covered. &lt;code>httptestmock.Mock&lt;/code> has a method called &lt;code>BuildNewClient&lt;/code> that will give you a &lt;code>*http.Client&lt;/code>. You can also call &lt;code>GetTestFunc&lt;/code> and this
will give you a &lt;code>TestHttpFunc&lt;/code>, which is a type that implements &lt;code>http.RoundTripper&lt;/code> and another function that has the same signature than &lt;code>Do&lt;/code> in &lt;code>http.Client&lt;/code>. You can integrate this library into your code in all these ways.&lt;/p>
&lt;p>You are probably thinking &amp;ldquo;Oh this thing modifies the global &lt;code>http.DefaultClient&lt;/code>. That could cause massive side effects&amp;rdquo; And yes, you are correct. This is why &lt;code>InjectInClient&lt;/code> returns a function. Calling it will restore the state of the client to what it was before the test. And you must make sure to defer that, so no other tests can potentially be affected by the mutation.&lt;/p>
&lt;p>You can keep on adding more tests in the block, with different payloads and different responses, writing expectations for every case. All the information of the test is in the test itself. No need to chase other files or look in logs from another process.&lt;/p>
&lt;p>Also, no side effects. All the state of the world lives there in your test run. Your response will be what the &lt;code>Return&lt;/code> property indicates will be. No surprises. That&amp;rsquo;s how a test should be.&lt;/p>
&lt;h2 id="learn-by-looking">Learn By Looking&lt;/h2>
&lt;p>If you need a more comprehensive example. You can take a look at &lt;a href="https://github.com/mnavarrocarter/transbank">this library I&amp;rsquo;m building&lt;/a>. It&amp;rsquo;s an SDK for a third party http service from Chile called Transbank. One of its services, Webpay, allows you to integrate with their payment gateway. &lt;a href="https://github.com/mnavarrocarter/transbank/blob/main/webpay/create_test.go">I&amp;rsquo;m using &lt;code>httpclientmock&lt;/code> to test the integration&lt;/a>.&lt;/p>
&lt;h2 id="going-solo">Going Solo&lt;/h2>
&lt;p>Of course, you don&amp;rsquo;t need to use a custom library for testing. As long as you can create your own &lt;code>http.RoundTripper&lt;/code> (with some assertions about a request and the building of a response) and pass that to the &lt;code>http.Client&lt;/code> you are using, you&amp;rsquo;ll be fine.&lt;/p>
&lt;h1 id="the-business-answer">The Business Answer&lt;/h1>
&lt;p>Now, all good so far? Well, not so fast! As you know, we are in the real world trying to bring value to our business partners. And they don&amp;rsquo;t care as much about in-memory deterministic testing or testing theory or stuff like that. They want to know the answer to one single and simple question: &lt;strong>will this integration work for the end user&lt;/strong>.&lt;/p>
&lt;p>User Acceptance Testing (or UAT) tries to answer that question, and it is a freaking art. This is one of the most difficult tests to automate. We cannot use the tests suites we wrote because we are testing conformity to a spec, remember? Those tests cannot tell us if the integration will work, which is the purpose of UAT.&lt;/p>
&lt;p>UAT tests deserve a test suite of their own, usually excluded from running in the normal CI process. They should be run prior to a deployment (usually against a release candidate version) against a real testing/staging environment. Is in this test scenario when it makes sense to hit a real server.&lt;/p>
&lt;p>Now, it is not as simple as write some logic and hit the server. It is more complex than that.&lt;/p>
&lt;p>You see, now we are dealing with all kind of side effects and statefulness. If we want to test an endpoint called &lt;code>GET /accounts/123&lt;/code> we need to make sure that the account with id &lt;code>123&lt;/code> exists in the system before doing that, so we probably need to call &lt;code>POST /accounts&lt;/code> first with some payload. In almost every UAT test there are some calls that depend on state obtained by other calls. For this reason, UAT test suites usually involve a &lt;em>journey&lt;/em>. They test a complete flow, from start to finish. They are not isolated tests like your normal Unit Tests. You&amp;rsquo;ll find yourself doing calls, retrieving state and then using that state to do some more calls that will continue to change the state of a server.&lt;/p>
&lt;p>Of course, I don&amp;rsquo;t have to mention that this could fail at any point of the journey for some weird reason.&lt;/p>
&lt;p>Another thing I&amp;rsquo;ve found to be really complex is that environment statefulness makes it really hard to reuse any kind of identifier, because you want to make sure that the test starts with a clean slate every time and you don&amp;rsquo;t know if the third party service testing environment you are using cleans up every day.&lt;/p>
&lt;p>Due to their messiness and complexity of implementing them automatically, UAT testing is usually done manually, but this is very prone to errors. At the end of the day, all depends on how complex is the integration you are building. You are in a lucky position if most of the calls of your third party service are idempotent, for example.&lt;/p>
&lt;hr>
&lt;p>These are just some of my ideas, beliefs and past experiences with testing. I hope they can make some sense for you and that will guide you to take the best approach you can to test your integrations in Golang.&lt;/p></content></item></channel></rss>