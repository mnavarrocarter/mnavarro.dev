<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#282A36"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><title>Implementing count endpoints using semantic HTTP - mnavarro.dev</title><meta name=description content="How to take advantage of the features already available in HTTP to implement count functionality in your apis."><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"mnavarro.dev","url":"https:\/\/mnavarro.dev\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"https:\/\/mnavarro.dev\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/mnavarro.dev\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"https:\/\/mnavarro.dev\/posts\/semantic-http-count-endpoints\/","name":"Implementing count endpoints using semantic h t t p"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":""},"headline":"Implementing count endpoints using semantic HTTP","description":"The HTTP protocol, the REST architectural pattern and API design are amongst my favorite topics in software development. I closely follow the latest RFCs, technologies and standards built over these, and over the years I\x26rsquo;ve learned how not to repeat the mistakes of the past by improving the way I used to to things.\nCount functionality implemented in a poor way is one of those mistakes. Back in the day I would have my api resources implement a count endpoint like this: GET \/some-resource\/count.","inLanguage":"en","wordCount":1071,"datePublished":"2020-10-15T01:00:00","dateModified":"2020-10-15T01:00:00","image":"https:\/\/mnavarro.dev\/","keywords":["http, rest, apis"],"mainEntityOfPage":"https:\/\/mnavarro.dev\/posts\/semantic-http-count-endpoints\/","publisher":{"@type":"Organization","name":"https:\/\/mnavarro.dev\/","logo":{"@type":"ImageObject","url":"https:\/\/mnavarro.dev\/","height":60,"width":60}}}</script><meta property="og:title" content="Implementing count endpoints using semantic HTTP"><meta property="og:description" content="How to take advantage of the features already available in HTTP to implement count functionality in your apis."><meta property="og:url" content="https://mnavarro.dev/posts/semantic-http-count-endpoints/"><meta property="og:type" content="website"><meta property="og:site_name" content="mnavarro.dev"><meta name=twitter:title content="Implementing count endpoints using semantic HTTP"><meta name=twitter:description content="How to take advantage of the features already available in HTTP to implement count functionality in your apis."><meta name=twitter:card content="summary"><meta name=generator content="Hugo 0.71.0"><link rel=alternate href=https://mnavarro.dev/index.xml type=application/rss+xml title=mnavarro.dev><link rel=stylesheet href=https://mnavarro.dev/css/style.css><link rel=preload href="https://fonts.googleapis.com/css?family=PT+Mono&display=swap" as=style onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel=stylesheet href="https://fonts.googleapis.com/css?family=PT+Mono&display=swap"></noscript><link rel=preload href=https://mnavarro.dev/css/syntax.css as=style onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://mnavarro.dev/css/syntax.css></noscript><script async defer data-domain=mnavarro.dev src=https://stats.mnavarro.dev/js/index.js></script></head><body><header><div class=wrapper><p class="site-brand muted lambda terminal"><a href=https://mnavarro.dev/>mnavarro.dev</a></p><nav><ul><li><a title=Blog href=/>Blog</a></li><li><a title=About href=/about>About</a></li><li><a title=Media href=/media>Media</a></li><li><a title="Atom Feed" href=/index.xml>Rss</a></li></ul></nav></div></header><main><div class=wrapper><article><h1 class=post-title>Implementing count endpoints using semantic HTTP</h1><p class=small>15 October 2020
| 6 minutes read
| 1071 words</p><div class=content><p>The HTTP protocol, the REST architectural pattern and API design are amongst my favorite topics in software development. I closely follow the latest RFCs, technologies and standards built over these, and over the years I&rsquo;ve learned how not to repeat the mistakes of the past by improving the way I used to to things.</p><p>Count functionality implemented in a poor way is one of those mistakes. Back in the day I would have my api resources implement a count endpoint like this: <code>GET /some-resource/count</code>. This would return a json along these lines:</p><div class=highlight><pre class=chroma><code class=language-json data-lang=json><span class=p>{</span>
    <span class=nt>&#34;count&#34;</span><span class=p>:</span> <span class=mi>3253</span>
<span class=p>}</span>
</code></pre></div><p>The problem with this approach is manyfold. I&rsquo;ll point the issues and explain why this is not a good idea, and then I will propose an alternative approach.</p><h2 id=its-harder-to-maintain>It&rsquo;s Harder to Maintain</h2><p>If you define count as an endpoint, you have to implement the handler for that endpoint explicitly for every resource. (This unless you are creating your apis with schema definitions and code generation tools).</p><p>In PHP, would look something like this:</p><div class=highlight><pre class=chroma><code class=language-php data-lang=php><span class=cp>&lt;?php</span>

<span class=nv>$router</span><span class=o>-&gt;</span><span class=na>nested</span><span class=p>(</span><span class=s1>&#39;/users&#39;</span><span class=p>,</span> <span class=k>function</span> <span class=p>(</span><span class=nv>$router</span><span class=p>)</span> <span class=p>{</span>
    <span class=nv>$router</span><span class=o>-&gt;</span><span class=na>get</span><span class=p>(</span><span class=s1>&#39;/&#39;</span><span class=p>,</span> <span class=nx>indexUsers</span><span class=p>());</span>
    <span class=nv>$router</span><span class=o>-&gt;</span><span class=na>get</span><span class=p>(</span><span class=s1>&#39;/count&#39;</span><span class=p>,</span> <span class=nx>countUsers</span><span class=p>());</span>
    <span class=nv>$router</span><span class=o>-&gt;</span><span class=na>get</span><span class=p>(</span><span class=s1>&#39;/:id&#39;</span><span class=p>,</span> <span class=nx>showUser</span><span class=p>())</span>
<span class=p>});</span>

<span class=nv>$router</span><span class=o>-&gt;</span><span class=na>nested</span><span class=p>(</span><span class=s1>&#39;/likes&#39;</span><span class=p>,</span> <span class=k>function</span> <span class=p>(</span><span class=nv>$router</span><span class=p>)</span> <span class=p>{</span>
    <span class=nv>$router</span><span class=o>-&gt;</span><span class=na>get</span><span class=p>(</span><span class=s1>&#39;/&#39;</span><span class=p>,</span> <span class=nx>indexLikes</span><span class=p>());</span>
    <span class=nv>$router</span><span class=o>-&gt;</span><span class=na>get</span><span class=p>(</span><span class=s1>&#39;/count&#39;</span><span class=p>,</span> <span class=nx>countLikes</span><span class=p>());</span>
    <span class=nv>$router</span><span class=o>-&gt;</span><span class=na>get</span><span class=p>(</span><span class=s1>&#39;/:id&#39;</span><span class=p>,</span> <span class=nx>showLike</span><span class=p>())</span>
<span class=p>});</span>
</code></pre></div><p>Another downside of this, is that due to the way routing engines work, you need to define the <code>/count</code> endpoint before the <code>/:id</code>. Otherwise <code>count</code> will match as a resource of users, probably giving you a 404. I&rsquo;ve seen routing bugs like this more times that I would like to. Junior developers can spend hours on a bug like this trying to figure our why their routes don&rsquo;t match.</p><p>So for every time you implement a new resource, you must remember and implement their corresponding count also.</p><h2 id=tends-to-duplication>Tends to duplication</h2><p>If you are a good api developer, then you are building filtering logic using query params over your collection endpoint. In other words, you are doing <code>GET /users?status=inactive&role=admin</code> instead of <code>GET/users-inactive-and-admin</code>. The main benefit of this is composability, and also mental sanity. Query params can be composed together to form collections representations with different rules and filters, instead of binding a hard-coded, uncomposable route to yet another handler.</p><p>Chances are you want your count endpoints to use that filtering logic too. If you are not a careful developer, you might be temped to just copy and paste the code that handles the query params into the count methods, making it harder to maintain. Kudos to you if you thought of extracting that to a separate method/service, but I would say that while you ara avoiding duplication, you are missing the larger picture: maybe the duplication is an indication that those two things should not be separated in the first place.</p><h2 id=breaks-rest>Breaks REST</h2><p>Even though is perfectly possible to implement count in the aforementioned way, that approach does not follow the REST standard. REST focuses on operations over resources. Resources can be represented inside a collection or as a single unit, but that representation must be consistent. Traditionally, this has been implemented in apis as <code>GET /resource</code> for collections and <code>GET /resource/identifier</code> for a single resource. <code>GET /resource/count</code> gives the impression of a single resource with the identifier <code>count</code>. But this &ldquo;resource&rdquo; is special: it does not return the same representation: just a number.</p><p><strong>The truth is that a count is metadata about a collection of resources</strong>, so it should not be implemented at the path that traditionally has been used to define single resources. We have see that this can confuse the routing engine, but also a client of your api.</p><h2 id=a-better-approach>A Better Approach</h2><p>Let&rsquo;s remember our use case. We want to count resources in a collection. Sometimes we would use filters to count them and we want the count to change on those filters. But we don&rsquo;t want to use another endpoint because it&rsquo;s cumbersome and leads to confusion. As we said, count is metadata of a collection so, why not put the count in the collection endpoint? Mmm&mldr;will something like this work?</p><div class=highlight><pre class=chroma><code class=language-json data-lang=json><span class=p>{</span>
    <span class=nt>&#34;meta&#34;</span><span class=p>:</span> <span class=p>[</span>
        <span class=s2>&#34;count&#34;</span><span class=err>:</span> <span class=mi>13532</span><span class=p>,</span>
        <span class=s2>&#34;page&#34;</span><span class=err>:</span> <span class=mi>13</span>
    <span class=p>],</span>
    <span class=nt>&#34;data&#34;</span><span class=p>:</span> <span class=p>[</span>
        <span class=err>...</span>
    <span class=p>]</span>
<span class=p>}</span>
</code></pre></div><p>This is better, but not ideal. What happens if I just need the count? How do I get rid of the unnecessary json rendering of the representation is that&rsquo;s the case?</p><p>Well, turns that we a bit of twaeking and some semantic HTTP we can do better. HTTP has an obscure verb that can help us here, a verb to return just the headers of a request, but not the body: <strong>the <code>HEAD</code> verb</strong>.</p><p>By HTTP spec, <code>HEAD</code> should not have a return body but must have the exact same headers than the normal <code>GET</code> request. You would be happy to know that the most popular routing libraries match <code>HEAD</code> requests to your <code>GET</code> requests automatically for you. This is done in the <a href=https://stackoverflow.com/questions/22118598/laravel-routes-gethead>Laravel Router</a> for example.</p><p>So, what if we move the <code>meta</code> object we defined in the json to the response headers? Is not that the purpose of the headers in HTTP, to serve as metadata? So, we can have a response like this:</p><div class=highlight><pre class=chroma><code class=language-http data-lang=http><span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span> <span class=m>200</span> <span class=ne>OK</span>
<span class=n>Date</span><span class=o>:</span> <span class=l>Sun, 10 Oct 2010 23:26:07 GMT</span>
<span class=n>Server</span><span class=o>:</span> <span class=l>Apache/2.2.8 (Ubuntu) mod_ssl/2.2.8 OpenSSL/0.9.8g</span>
<span class=n>Content-Type</span><span class=o>:</span> <span class=l>application/json</span>
<span class=n>X-Total-Count</span><span class=o>:</span> <span class=l>23432</span>

<span class=p>[</span>
    <span class=p>{</span>
        <span class=nt>&#34;id&#34;</span><span class=p>:</span> <span class=s2>&#34;some-id&#34;</span><span class=p>,</span>
        <span class=nt>&#34;name: &#34;</span><span class=err>some-name&#34;</span>
    <span class=p>},</span>
    <span class=p>{</span>
        <span class=err>...</span>
    <span class=p>}</span>
<span class=p>]</span>
</code></pre></div><p>We moved the array to the top level and move the metadata to the headers. Now, if we want just the count, we can simply do <code>HEAD /users</code> and return just the headers, but not build a json body when the request method is <code>HEAD</code>. You save a database call and a lot of transformation logic, and you still get your count. And you can use your regular query params to filter data over that endpoint.</p><h2 id=extra-advice>Extra Advice</h2><p>I like to separate my actual resources from the fact they are a paginatable and countable collection of things. So, I usually split my resource logic with my collection handling logic.</p><p>My collection handling logic just uses a simple interface:</p><div class=highlight><pre class=chroma><code class=language-php data-lang=php><span class=cp>&lt;?php</span>

<span class=k>interface</span> <span class=nx>Collection</span> <span class=p>{</span>

    <span class=k>public</span> <span class=k>function</span> <span class=nf>count</span><span class=p>()</span><span class=o>:</span> <span class=nx>int</span><span class=p>;</span>

    <span class=k>public</span> <span class=k>function</span> <span class=nf>slice</span><span class=p>(</span><span class=nx>int</span> <span class=nv>$offset</span><span class=p>,</span> <span class=nx>int</span> <span class=nv>$size</span><span class=p>)</span><span class=o>:</span> <span class=nx>Collection</span><span class=p>;</span>

    <span class=k>public</span> <span class=k>function</span> <span class=nf>iterator</span><span class=p>()</span><span class=o>:</span> <span class=nx>iterable</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>What is under this I don&rsquo;t really care much and long as it gives me a total count, and I can slice it for pagination purposes and filter over it.</p><p>Then, I have a single collection handler that, when passed a <code>Collection</code> interface, is capable of counting, paginating and rendering the body using the iterator if necessary.</p><hr><p>Hope you liked this article and that you find it useful.</p></div><div class=post-terms><p class=small>Taggged
<a href=https://mnavarro.dev/tags/http/>http</a>,
<a href=https://mnavarro.dev/tags/rest/>rest</a>,
<a href=https://mnavarro.dev/tags/apis/>apis</a>,</p></div><div class=post-nav><div class=post-nav-prev><a href=https://mnavarro.dev/posts/namespaced-taxonomy-sindrome/>Namespaced Taxonomy Syndrome</a></div></div></article><div class=comments><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"mnavarro"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></main><footer><div class=wrapper><p class=small>Last Modified:
15 October 2020</p><p class="muted lambda">Process exited with code <span id=status>0</span></p></div></footer></body></html>