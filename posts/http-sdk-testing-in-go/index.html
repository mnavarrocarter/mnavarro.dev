<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="#282A36"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><title>Testing HTTP SDKs in Golang - mnavarro.dev</title><meta name=description content="Some thoughts on how to test code that integrates with third party HTTP services and apis"><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"mnavarro.dev","url":"https:\/\/mnavarro.dev\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"https:\/\/mnavarro.dev\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/mnavarro.dev\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"https:\/\/mnavarro.dev\/posts\/http-sdk-testing-in-go\/","name":"Testing h t t p s d ks in golang"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":""},"headline":"Testing HTTP SDKs in Golang","description":"How do you test code that integrates with a third party HTTP service?\nThe Philosophical Answer If you think about it, it is not an easy question to answer. Maybe you have already some strong opinions formed about it. But, in my experience, answers to this question differ greatly among developers, even between seasoned ones.\nI believe those differences are due to some preconceived ideas or different definitions about what testing is.","inLanguage":"en","wordCount":2841,"datePublished":"2021-09-08T20:00:00","dateModified":"2021-09-08T20:00:00","image":"https:\/\/mnavarro.dev\/","keywords":["testing, golang, http"],"mainEntityOfPage":"https:\/\/mnavarro.dev\/posts\/http-sdk-testing-in-go\/","publisher":{"@type":"Organization","name":"https:\/\/mnavarro.dev\/","logo":{"@type":"ImageObject","url":"https:\/\/mnavarro.dev\/","height":60,"width":60}}}</script><meta property="og:title" content="Testing HTTP SDKs in Golang"><meta property="og:description" content="Some thoughts on how to test code that integrates with third party HTTP services and apis"><meta property="og:url" content="https://mnavarro.dev/posts/http-sdk-testing-in-go/"><meta property="og:type" content="website"><meta property="og:site_name" content="mnavarro.dev"><meta name=twitter:title content="Testing HTTP SDKs in Golang"><meta name=twitter:description content="Some thoughts on how to test code that integrates with third party HTTP services and apis"><meta name=twitter:card content="summary"><meta name=generator content="Hugo 0.71.0"><link rel=alternate href=https://mnavarro.dev/index.xml type=application/rss+xml title=mnavarro.dev><link rel=stylesheet href=https://mnavarro.dev/css/style.css><link rel=preload href="https://fonts.googleapis.com/css?family=PT+Mono&display=swap" as=style onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel=stylesheet href="https://fonts.googleapis.com/css?family=PT+Mono&display=swap"></noscript><link rel=preload href=https://mnavarro.dev/css/syntax.css as=style onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://mnavarro.dev/css/syntax.css></noscript><script async defer data-domain=mnavarro.dev src=https://mnavarro.dev/stats.js></script></head><body><header><div class=wrapper><p class="site-brand muted lambda terminal"><a href=https://mnavarro.dev/>mnavarro.dev</a></p><nav><ul><li><a title=Blog href=/>Blog</a></li><li><a title=About href=/about>About</a></li><li><a title=Media href=/media>Media</a></li><li><a title="Atom Feed" href=/index.xml>Rss</a></li></ul></nav></div></header><main><div class=wrapper><article><h1 class=post-title>Testing HTTP SDKs in Golang</h1><p class=small>8 September 2021
| 14 minutes read
| 2841 words</p><div class=content><p>How do you test code that integrates with a third party HTTP service?</p><h1 id=the-philosophical-answer>The Philosophical Answer</h1><p>If you think about it, it is not an easy question to answer. Maybe you have already some strong opinions formed about it. But, in my experience, answers to this question differ greatly among developers, even between seasoned ones.</p><p>I believe those differences are due to some preconceived ideas or different definitions about what testing is. For example, some people believe that testing is making sure your code works. The problem with that definition is that it is too vague; &ldquo;it works&rdquo; can mean anything.</p><link rel=stylesheet href=https://mnavarro.dev/css/hugo-easy-gallery.css><div class=box><figure itemprop=associatedMedia itemscope itemtype=http://schema.org/ImageObject><div class=img><img itemprop=thumbnail src=https://blog.sergeyev.info/images/works-on-my-machine/the-line.jpg alt=https://blog.sergeyev.info/images/works-on-my-machine/the-line.jpg></div><a href=https://blog.sergeyev.info/images/works-on-my-machine/the-line.jpg itemprop=contentUrl></a><figcaption><h4>Works on my Machine!</h4></figcaption></figure></div><p>Take, for instance, the following (too familiar) situation: you are told to code a service (or SDK) that integrates with a third party api or http service. As is usual with integrations, confusing or incomplete specs are passed around. Nonetheless, that is sufficient to do your job. You decide to test creating a mock server based on the spec and build your suite to a very good coverage. So far so good.</p><p>But, when the day comes to do some acceptance testing against the QA environment of the service you are integrating to, you realized nothing worked. Turns out services needed an extra header that was not included in any spec. No problem though; you add it to the code, update your tests and move forward.</p><p>I&rsquo;ll come back to this story to explore other relevant topics later. For now, I want to use it to ask you a question. Would you say that the initial version released to test against QA &ldquo;worked&rdquo;? Well, it&rsquo;s a tricky one, isn&rsquo;t it? It did not worked in the sense that it did not integrate correctly because of the missing header. It worked in the sense that the program did what it was coded to do with the available knowledge at the time.</p><p>Based on this, I would like to make the main point of this article, from which every other point flows. <strong>Testing is not making sure your program does something correctly; testing is making sure your program does what the code says it does.</strong> In our previously mentioned story, we cannot ensure a correct integration until we have hit a real service (and not a mock), but we can have good tests that ensure the program is doing what we have coded it to do.</p><p>I think the distinction of these two is greatly accentuated in integrations with third party http services. Unless you have an spec that is automatically generated from the service code, until you start hitting endpoints, you can never know for sure if you have integrated correctly or not.</p><p>In my opinion, the sooner we embrace this reality, the better. Once we do, we will be able to go and ask ourselves the next question.</p><h2 id=what-then-do-we-test>What then do we test?</h2><p>So, if we cannot test that our SDK integrates correctly with the service. What do we test then? The answer is: <strong>we test that our code follows what we understand of the specification we were given.</strong></p><p>For instance, if the specification says that we should send an <code>Authorization</code> header with some sort of token, we test that (1) A request is created containing the <code>Authorization</code> header and (2) that the passed token value is indeed the same that is injected in the header. Similar principles follow for URL, method and body.</p><p>The following of a specification does not have only to do with the expectations about a request, but also with the correct handling of a response. This means we should also test that our code follows the specification when handling responses.</p><p>We should map status codes to certain errors, or react to different content types, or deserialize certain payloads to some types without data loss, etc. We should test that our code does this based on the spec.</p><p>Okay, I&rsquo;m sure you are getting very impatient and want to get to the &ldquo;how&rdquo; of testing a third party http integration. Just allow me to say one more thing.</p><h2 id=what-are-we-not-testing>What are we not testing?</h2><p>Many developers understand all that I&rsquo;ve written. So, they take their keyboards and decide that the best way to test the aforementioned things is just by spinning up a temporary web server process, listening in a random port, that is pre-configured to respond to requests mapping certain methods and urls to certain responses. Most people call this a <em>mock server</em>.</p><p>No blame on them! I&rsquo;ve seen this approach being endorsed by <a href="https://youtu.be/rWBSMsLG8po?t=2413">really prominent Go developers</a>. And I think it is specially prominent in Go due to the fact that it is indeed very easy to spin up a server in a separate Goroutine.</p><p>However, this approach is often unnecessary and overly complex. Let me explain why.</p><h3 id=we-are-not-testing-tcptlshttp>We are not testing TCP/TLS/HTTP!</h3><p>First, there is no need to send our <code>*http.Request</code> over a TCP socket to a server, have the server parse the request and end up with a <code>*http.Request</code> again in a completely different process, that then will be passed to a handler that will match our request and return a response.</p><div class=highlight><pre class=chroma><code class=language-txt data-lang=txt>http.Request --&gt; Http Client --&gt; TCP Socket --&gt; Server --&gt; Http Parser --&gt; http.Request --&gt; handler -&gt; http.Response
</code></pre></div><p>We can simplify this massively, bypassing all the TCP, server stuff and just doing things in memory, for instance, in a function.</p><div class=highlight><pre class=chroma><code class=language-txt data-lang=txt>http.Request -&gt; function -&gt; http.Response
</code></pre></div><p>And this is fine, because we are not testing TCP, nor TLS, nor the HTTP protocol. The Go standard library already has tests for all those packages and functions. We want to test <em>our</em> code.</p><p>In order for us to test that our code complies to a spec, there is no need then to spin up a web server.</p><p>Plus, if something happens with that server, it will be really hard to debug.</p><h3 id=we-are-not-testing-routing>We are not testing routing!</h3><p>Even when not using server-over-TCP mocking techniques, but in-memory ones, some people still go with building some kind of in-memory testing &ldquo;server&rdquo; that returns responses based on some matching logic. Usually this takes the form of matching the method and the url.</p><p>Again, this is completely unnecessary, and it could lead to undesirable side-effects in testing, plus a couple of more issues.</p><p>It is unnecessary because, remember, we are testing that our code conforms to a spec. In other words, we are testing that we send a request with the correct contents and that we are capable to handle certain responses. We are not testing routing (that a request with a certain method and URL with gives us a certain response).</p><p>This approach usually leads to side effects. Since this massive, respond-to-everything, in-memory mock of a server needs to be configured somewhere, it usually is outside the tested code. If someone changes an id, or accidentally creates another request with the same url there is potential breakage.</p><p>Also, there is no clear contract regarding to what should be the response when a request of this mock cannot be matched. This usually weakens error handling code.</p><p>Finally, a mock like this ignores the fact that some HTTP operations are not idempotent: the same method and url combination can and will give different answers based on the internal state of the server at the time of the call. It is really hard to mock that using this approach.</p><p>It&rsquo;s better not to try to play any matching games and do something deterministic and straightforward.</p><h1 id=the-practical-answer>The Practical Answer</h1><p>Now that I have ranted enough about these things, is time I explain my proposed approach.</p><p>Let&rsquo;s suppose that we have an third party service with an endpoint <code>POST /input</code>. This endpoint takes a <code>application/json</code> payload that only contains
one key <code>message</code>, and can be an string of any length.</p><p>The service returns an <code>application/json</code> payload with the same structure: again, the object with a <code>message</code> key.</p><p>This is how I would implement it in Go. Read the comments so you get a better understanding.</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>fakesdk</span>

<span class=c1>// A main client struct to hold everything together
</span><span class=c1></span><span class=kd>type</span> <span class=nx>FakeApiClient</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=nx>client</span>  <span class=nx>HTTPClient</span>
	<span class=nx>baseUrl</span> <span class=kt>string</span>
<span class=p>}</span>

<span class=c1>// A constructor to make that client with good defaults
</span><span class=c1></span><span class=kd>func</span> <span class=nf>NewFakeApiClient</span><span class=p>(</span><span class=nx>baseUrl</span> <span class=kt>string</span><span class=p>)</span> <span class=o>*</span><span class=nx>FakeApiClient</span> <span class=p>{</span>
    <span class=k>return</span> <span class=o>&amp;</span><span class=nx>FakeApiClient</span><span class=p>{</span>
        <span class=nx>client</span><span class=p>:</span> <span class=nx>http</span><span class=p>.</span><span class=nx>DefaultClient</span><span class=p>,</span>
        <span class=nx>baseUrl</span><span class=p>:</span> <span class=nx>baseUrl</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=c1>// Some people like to make an interface with the same signature
</span><span class=c1>// as http.Client.Do function so they can swap implementations for
</span><span class=c1>// testing. http.RoundTripper can do this already, but well, 
</span><span class=c1>// everyone has their own preference. 
</span><span class=c1></span><span class=kd>type</span> <span class=nx>HTTPClient</span> <span class=kd>interface</span> <span class=p>{</span>
	<span class=nf>Do</span><span class=p>(</span><span class=nx>req</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>(</span><span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Response</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
<span class=p>}</span>

<span class=c1>// This creates the request. Pretty standard stuff here.
</span><span class=c1>// The only detail is that we need to serialize from json and make
</span><span class=c1>// sure we put the right content type.
</span><span class=c1>// Oh, and that we pass the context to the request!
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>cl</span> <span class=o>*</span><span class=nx>FakeApiClient</span><span class=p>)</span> <span class=nf>mustMakeRequest</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>method</span><span class=p>,</span> <span class=nx>path</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>input</span> <span class=kd>interface</span><span class=p>{})</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span> <span class=p>{</span>
	<span class=kd>var</span> <span class=nx>body</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Reader</span>

	<span class=k>if</span> <span class=nx>input</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=nx>b</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>Marshal</span><span class=p>(</span><span class=nx>input</span><span class=p>)</span>
		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
			<span class=nb>panic</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span> <span class=c1>// Developer error
</span><span class=c1></span>		<span class=p>}</span>
		<span class=nx>body</span> <span class=p>=</span> <span class=nx>bytes</span><span class=p>.</span><span class=nf>NewBuffer</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
	<span class=p>}</span>

	<span class=nx>url</span> <span class=o>:=</span> <span class=nx>cl</span><span class=p>.</span><span class=nx>baseUrl</span> <span class=o>+</span> <span class=nx>path</span>

	<span class=nx>req</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>http</span><span class=p>.</span><span class=nf>NewRequest</span><span class=p>(</span><span class=nx>method</span><span class=p>,</span> <span class=nx>url</span><span class=p>,</span> <span class=nx>body</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=nb>panic</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span> <span class=c1>// Developer error
</span><span class=c1></span>	<span class=p>}</span>

	<span class=nx>req</span><span class=p>.</span><span class=nx>Header</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=s>&#34;Content-Type&#34;</span><span class=p>,</span> <span class=s>&#34;application/json&#34;</span><span class=p>)</span>

	<span class=k>return</span> <span class=nx>req</span><span class=p>.</span><span class=nf>WithContext</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
<span class=p>}</span>

<span class=c1>// The fake input struct
</span><span class=c1></span><span class=kd>type</span> <span class=nx>FakeInput</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=nx>Message</span> <span class=kt>string</span> <span class=s>`json:&#34;message&#34;`</span>
<span class=p>}</span>

<span class=c1>// The fake output struct
</span><span class=c1></span><span class=kd>type</span> <span class=nx>FakeOutput</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=nx>Message</span> <span class=kt>string</span> <span class=s>`json:&#34;message&#34;`</span>
<span class=p>}</span>

<span class=c1>// This is the actual method that will be used in client code.
</span><span class=c1>// Pretty standard stuff too. Sends the request and handles any error.
</span><span class=c1>// Also decodes the payload.
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>cl</span> <span class=o>*</span><span class=nx>FakeApiClient</span><span class=p>)</span> <span class=nf>PostInput</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>input</span> <span class=o>*</span><span class=nx>FakeInput</span><span class=p>)</span> <span class=p>(</span><span class=o>*</span><span class=nx>FakeOutput</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>req</span> <span class=o>:=</span> <span class=nx>cl</span><span class=p>.</span><span class=nf>mustMakeRequest</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;POST&#34;</span><span class=p>,</span> <span class=s>&#34;/input&#34;</span><span class=p>,</span> <span class=nx>input</span><span class=p>)</span>

	<span class=nx>res</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>cl</span><span class=p>.</span><span class=nx>client</span><span class=p>.</span><span class=nf>Do</span><span class=p>(</span><span class=nx>req</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
	<span class=p>}</span>

	<span class=k>defer</span> <span class=nx>res</span><span class=p>.</span><span class=nx>Body</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>

    <span class=k>if</span> <span class=nx>res</span><span class=p>.</span><span class=nx>StatusCode</span> <span class=o>&gt;=</span> <span class=mi>400</span> <span class=p>{</span>
        <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;server responded with code %d&#34;</span><span class=p>,</span> <span class=nx>res</span><span class=p>.</span><span class=nx>StatusCode</span><span class=p>)</span>
    <span class=p>}</span>

	<span class=nx>out</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>FakeOutput</span><span class=p>{}</span>

	<span class=nx>err</span> <span class=p>=</span> <span class=nx>json</span><span class=p>.</span><span class=nf>NewDecoder</span><span class=p>(</span><span class=nx>res</span><span class=p>.</span><span class=nx>Body</span><span class=p>).</span><span class=nf>Decode</span><span class=p>(</span><span class=nx>out</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
	<span class=p>}</span>

	<span class=k>return</span> <span class=nx>out</span><span class=p>,</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></div><p>Now, the only thing I need to test is that I send the correct request and I&rsquo;m capable to handle all possible responses or eventual socket errors. That&rsquo;s it. Nothing else.</p><p>Sending the the correct request in this case means that the method is correct, the url too, that the body gets serialized to json correctly and that the compulsory headers are present and with the correct values.</p><p>Being capable to handle all possible responses means that I should code expectations for when my code fails. For instance, if I get a response with a status code 400, then my code should return an error saying &ldquo;server responded with code 400&rdquo;.</p><p>Now, doing all these checks on the request and building all the responses for every test case would be very verbose. Luckily, I&rsquo;ve created a package just for that. It is called <code>httpclientmock</code>. It is extremely simple and straight forward, and you are meant to use it in your test suites like this:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>fakesdk_test</span>

<span class=kd>var</span> <span class=nx>postInputTests</span> <span class=p>=</span> <span class=p>[]</span><span class=kd>struct</span> <span class=p>{</span>
	<span class=nx>name</span>       <span class=kt>string</span>
	<span class=nx>input</span>      <span class=o>*</span><span class=nx>FakeInput</span>
	<span class=nx>mock</span>       <span class=o>*</span><span class=nx>httpclientmock</span><span class=p>.</span><span class=nx>Mock</span>
	<span class=nx>assertions</span> <span class=kd>func</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>,</span> <span class=nx>output</span> <span class=o>*</span><span class=nx>FakeOutput</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
<span class=p>}{</span>
	<span class=p>{</span>
		<span class=nx>name</span><span class=p>:</span>  <span class=s>&#34;test one&#34;</span><span class=p>,</span>
		<span class=nx>input</span><span class=p>:</span> <span class=o>&amp;</span><span class=nx>FakeInput</span><span class=p>{</span><span class=s>&#34;This is a message sent&#34;</span><span class=p>},</span>
		<span class=nx>mock</span><span class=p>:</span> <span class=o>&amp;</span><span class=nx>httpclientmock</span><span class=p>.</span><span class=nx>Mock</span><span class=p>{</span>
			<span class=nx>Expect</span><span class=p>:</span> <span class=o>&amp;</span><span class=nx>httpclientmock</span><span class=p>.</span><span class=nx>Request</span><span class=p>{</span>
				<span class=nx>Method</span><span class=p>:</span> <span class=s>&#34;POST&#34;</span><span class=p>,</span>
				<span class=nx>Url</span><span class=p>:</span>    <span class=s>&#34;https://some.fake.service/input&#34;</span><span class=p>,</span>
				<span class=nx>Headers</span><span class=p>:</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>{</span>
					<span class=s>&#34;Content-Type&#34;</span><span class=p>:</span> <span class=s>&#34;application/json&#34;</span><span class=p>,</span>
				<span class=p>},</span>
				<span class=nx>Body</span><span class=p>:</span> <span class=p>[]</span><span class=nb>byte</span><span class=p>(</span><span class=s>`{&#34;message&#34;:&#34;This is a message sent&#34;}`</span><span class=p>),</span>
			<span class=p>},</span>
			<span class=nx>Return</span><span class=p>:</span> <span class=o>&amp;</span><span class=nx>httpclientmock</span><span class=p>.</span><span class=nx>Response</span><span class=p>{</span>
				<span class=nx>StatusCode</span><span class=p>:</span> <span class=mi>200</span><span class=p>,</span>
				<span class=nx>Headers</span><span class=p>:</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>{</span>
					<span class=s>&#34;Content-Type&#34;</span><span class=p>:</span> <span class=s>&#34;application/json&#34;</span><span class=p>,</span>
				<span class=p>},</span>
				<span class=nx>Body</span><span class=p>:</span> <span class=p>[]</span><span class=nb>byte</span><span class=p>(</span><span class=s>`{&#34;message&#34;:&#34;This is a message received&#34;}`</span><span class=p>),</span>
			<span class=p>},</span>
		<span class=p>},</span>
		<span class=nx>assertions</span><span class=p>:</span> <span class=kd>func</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>,</span> <span class=nx>output</span> <span class=o>*</span><span class=nx>FakeOutput</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
			<span class=k>if</span> <span class=nx>output</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
				<span class=nx>t</span><span class=p>.</span><span class=nf>Error</span><span class=p>(</span><span class=s>&#34;no output&#34;</span><span class=p>)</span>
			<span class=p>}</span>
			<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
				<span class=nx>t</span><span class=p>.</span><span class=nf>Error</span><span class=p>(</span><span class=s>&#34;an error has happened&#34;</span><span class=p>)</span>
			<span class=p>}</span>
		<span class=p>},</span>
	<span class=p>},</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>TestPostInput</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>client</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>FakeApiClient</span><span class=p>{</span><span class=nx>http</span><span class=p>.</span><span class=nx>DefaultClient</span><span class=p>,</span> <span class=s>&#34;https://some.fake.service&#34;</span><span class=p>}</span>
	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>test</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>postInputTests</span> <span class=p>{</span>
		<span class=nx>t</span><span class=p>.</span><span class=nf>Run</span><span class=p>(</span><span class=nx>test</span><span class=p>.</span><span class=nx>name</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
            <span class=c1>// Inject in client mutates http.DefaultClient transport.
</span><span class=c1></span>            <span class=c1>// The restore function restores the previous transport.
</span><span class=c1></span>			<span class=nx>restore</span> <span class=o>:=</span> <span class=nx>test</span><span class=p>.</span><span class=nx>mock</span><span class=p>.</span><span class=nf>InjectInClient</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
            <span class=c1>// We defer the restoring of the previous transport when the test finishes
</span><span class=c1></span>			<span class=k>defer</span> <span class=nf>restore</span><span class=p>()</span>
            <span class=c1>// Pass the input
</span><span class=c1></span>			<span class=nx>out</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>client</span><span class=p>.</span><span class=nf>PostInput</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>(),</span> <span class=nx>test</span><span class=p>.</span><span class=nx>input</span><span class=p>)</span>
			<span class=c1>// Assert about the output
</span><span class=c1></span>            <span class=nx>test</span><span class=p>.</span><span class=nf>assertions</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>out</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
		<span class=p>})</span>
	<span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>The benefits of using this library are huge. First, its ability to modify <code>http.DefaultClient</code> responsibly means you don&rsquo;t need to worry about dependency injection too much when setting up tests that send requests very deep in the call stack. So, you could use it for E2E tests without a problem.</p><p>If you wish to use better practices like dependency injection, no problem, we got you covered. <code>httptestmock.Mock</code> has a method called <code>BuildNewClient</code> that will give you a <code>*http.Client</code>. You can also call <code>GetTestFunc</code> and this
will give you a <code>TestHttpFunc</code>, which is a type that implements <code>http.RoundTripper</code> and another function that has the same signature than <code>Do</code> in <code>http.Client</code>. You can integrate this library into your code in all these ways.</p><p>You are probably thinking &ldquo;Oh this thing modifies the global <code>http.DefaultClient</code>. That could cause massive side effects&rdquo; And yes, you are correct. This is why <code>InjectInClient</code> returns a function. Calling it will restore the state of the client to what it was before the test. And you must make sure to defer that, so no other tests can potentially be affected by the mutation.</p><p>You can keep on adding more tests in the block, with different payloads and different responses, writing expectations for every case. All the information of the test is in the test itself. No need to chase other files or look in logs from another process.</p><p>Also, no side effects. All the state of the world lives there in your test run. Your response will be what the <code>Return</code> property indicates will be. No surprises. That&rsquo;s how a test should be.</p><h2 id=learn-by-looking>Learn By Looking</h2><p>If you need a more comprehensive example. You can take a look at <a href=https://github.com/mnavarrocarter/transbank>this library I&rsquo;m building</a>. It&rsquo;s an SDK for a third party http service from Chile called Transbank. One of its services, Webpay, allows you to integrate with their payment gateway. <a href=https://github.com/mnavarrocarter/transbank/blob/main/webpay/create_test.go>I&rsquo;m using <code>httpclientmock</code> to test the integration</a>.</p><h2 id=going-solo>Going Solo</h2><p>Of course, you don&rsquo;t need to use a custom library for testing. As long as you can create your own <code>http.RoundTripper</code> (with some assertions about a request and the building of a response) and pass that to the <code>http.Client</code> you are using, you&rsquo;ll be fine.</p><h1 id=the-business-answer>The Business Answer</h1><p>Now, all good so far? Well, not so fast! As you know, we are in the real world trying to bring value to our business partners. And they don&rsquo;t care as much about in-memory deterministic testing or testing theory or stuff like that. They want to know the answer to one single and simple question: <strong>will this integration work for the end user</strong>.</p><p>User Acceptance Testing (or UAT) tries to answer that question, and it is a freaking art. This is one of the most difficult tests to automate. We cannot use the tests suites we wrote because we are testing conformity to a spec, remember? Those tests cannot tell us if the integration will work, which is the purpose of UAT.</p><p>UAT tests deserve a test suite of their own, usually excluded from running in the normal CI process. They should be run prior to a deployment (usually against a release candidate version) against a real testing/staging environment. Is in this test scenario when it makes sense to hit a real server.</p><p>Now, it is not as simple as write some logic and hit the server. It is more complex than that.</p><p>You see, now we are dealing with all kind of side effects and statefulness. If we want to test an endpoint called <code>GET /accounts/123</code> we need to make sure that the account with id <code>123</code> exists in the system before doing that, so we probably need to call <code>POST /accounts</code> first with some payload. In almost every UAT test there are some calls that depend on state obtained by other calls. For this reason, UAT test suites usually involve a <em>journey</em>. They test a complete flow, from start to finish. They are not isolated tests like your normal Unit Tests. You&rsquo;ll find yourself doing calls, retrieving state and then using that state to do some more calls that will continue to change the state of a server.</p><p>Of course, I don&rsquo;t have to mention that this could fail at any point of the journey for some weird reason.</p><p>Another thing I&rsquo;ve found to be really complex is that environment statefulness makes it really hard to reuse any kind of identifier, because you want to make sure that the test starts with a clean slate every time and you don&rsquo;t know if the third party service testing environment you are using cleans up every day.</p><p>Due to their messiness and complexity of implementing them automatically, UAT testing is usually done manually, but this is very prone to errors. At the end of the day, all depends on how complex is the integration you are building. You are in a lucky position if most of the calls of your third party service are idempotent, for example.</p><hr><p>These are just some of my ideas, beliefs and past experiences with testing. I hope they can make some sense for you and that will guide you to take the best approach you can to test your integrations in Golang.</p></div><div class=post-terms><p class=small>Taggged
<a href=https://mnavarro.dev/tags/testing/>testing</a>,
<a href=https://mnavarro.dev/tags/golang/>golang</a>,
<a href=https://mnavarro.dev/tags/http/>http</a>,</p></div><div class=post-nav><div class=post-nav-prev><a href=https://mnavarro.dev/posts/environment-variables-done-right/>Environment Variables Done Right</a></div></div></article><div class=comments><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"mnavarro"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></main><footer><div class=wrapper><p class=small>Last Modified:
8 September 2021</p><p class="muted lambda">Process exited with code <span id=status>0</span></p></div></footer></body></html>