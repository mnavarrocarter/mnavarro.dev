<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Software Development on The Chilean Nerd</title><link>https://blog.mnavarro.dev/tags/software-development/</link><description>Recent content in Software Development on The Chilean Nerd</description><generator>Hugo -- gohugo.io</generator><language>en-GB</language><copyright>Â©2019 Matias Navarro Carter. CC-BY-SA.</copyright><lastBuildDate>Mon, 11 Apr 2022 18:00:00 +0100</lastBuildDate><atom:link href="https://blog.mnavarro.dev/tags/software-development/index.xml" rel="self" type="application/rss+xml"/><item><title>The Problem with Soft Deletes</title><link>https://blog.mnavarro.dev/posts/problem-with-soft-delete/</link><pubDate>Mon, 11 Apr 2022 18:00:00 +0100</pubDate><guid>https://blog.mnavarro.dev/posts/problem-with-soft-delete/</guid><description>If you have been in web development for a while you might have stumbled upon the concept of soft-deletes. Basically, it is a common pattern (or more exactly, anti-pattern) in database management that allows deleting items from a database while keeping the records there.
The implementation of this pattern usually involves a nullable timestamp column called deleted_at. When we delete a record, instead of a DELETE query we just simply run an UPDATE one and set that column to the current timestamp.</description><content>&lt;p>If you have been in web development for a while you might have stumbled upon
the concept of soft-deletes. Basically, it is a common pattern (or more exactly,
anti-pattern) in database management that allows deleting items from a database
while keeping the records there.&lt;/p>
&lt;p>The implementation of this pattern usually involves a nullable timestamp
column called &lt;code>deleted_at&lt;/code>. When we delete a record, instead of a &lt;code>DELETE&lt;/code>
query we just simply run an &lt;code>UPDATE&lt;/code> one and set that column to the current
timestamp. Then, deleted records can be hidden from the exposed public api by
adding a where clause like the following to every query:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sql" data-lang="sql">&lt;span style="color:#66d9ef">WHERE&lt;/span> deleted_at &lt;span style="color:#66d9ef">IS&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>A challenge while implementing this is that this clause must be added globally.
If you are using raw SQL queries this is hard to maintain and error prone. But most
frameworks have robust SQL abstractions that eliminate that issue by using
some plugin or library.&lt;/p>
&lt;h2 id="benefits--drawbacks">Benefits &amp;amp; Drawbacks&lt;/h2>
&lt;p>This technique has some benefits, like the ability to restore records that have been
accidentally removed, keep historical data for reporting purposes and avoid
dealing with referential constraints when deleting records in relational
databases. However, in engineering, not all that is shiny is gold. Although there
are some benefits with this technique, there are also some drawbacks.&lt;/p>
&lt;p>The first drawback is that there is a performance penalty your database has to
pay for this. Even if the &lt;code>deleted_at&lt;/code> column is indexed, still a full table scan
is needed to fetch non-deleted records. This of course harms performance
exponentially as your database table grows. Some people say this is the most
fundamental problem with this approach. I think I tend to agree, although the
impact of that drawback varies from application to application.&lt;/p>
&lt;p>But, I think there at least two more troubling issues here. One has to do with
referential integrity and another one with domain modeling.&lt;/p>
&lt;h3 id="soft-deletes-obscure-referential-integrity">Soft Deletes obscure referential integrity&lt;/h3>
&lt;p>When you soft delete a record in your database, none of the foreign key constraints
you have in place will be checked. This is seen as a feature for many. You won&amp;rsquo;t get
any constraint violation errors on any of your queries. Awesome!&lt;/p>
&lt;p>The problem is that foreign key constraints are there for a very important reason.
Bypassing them is often unwise. Let&amp;rsquo;s see a concrete example.&lt;/p>
&lt;p>Let&amp;rsquo;s think of a &lt;code>articles&lt;/code> table and a &lt;code>tags&lt;/code> table. Articles represent blog
posts, and you can tag them with any tag you would like. The relationship between
tags and articles is a many to many one, so you will model this in a &lt;code>article_tags&lt;/code>
pivot table. Simple.&lt;/p>
&lt;p>Now let&amp;rsquo;s say you go and delete a tag from the system. You get a massive
&lt;strong>Constraint Violation Error&lt;/strong> because that tag is being used in the &lt;code>article_tags&lt;/code> table
to actually tag some articles. You need to do something with those references
first. Ignoring that kind of problem is never good, because then you could
have inconsistencies in your data model. You should first correct the references
in &lt;code>article_tags&lt;/code> and then delete the actual tag.&lt;/p>
&lt;p>How to correct the references will depend on your use case or domain. For instance,
when does it make sense to remove a tag? Maybe there is a tag called &lt;strong>DDD&lt;/strong> and another
called &lt;strong>Domain Driven Design&lt;/strong> in your blog. You want to normalize this, and you
decide that &lt;strong>DDD&lt;/strong> will be removed and replaced with &lt;strong>Domain Driven Design&lt;/strong>.
Your delete then should look for the &lt;strong>DDD&lt;/strong> tag in &lt;code>article_tags&lt;/code> and replace
them with the &lt;strong>Domain Driven Design&lt;/strong> one, and then you proceed to delete the
&lt;strong>DDD&lt;/strong> tag from the &lt;code>tags&lt;/code> table.&lt;/p>
&lt;p>Or maybe you just don&amp;rsquo;t want to normalize anything and just delete a tag and all
of it&amp;rsquo;s references. In that case, you should delete the references first, and then
the actual tags.&lt;/p>
&lt;p>It is important that your program has this knowledge baked in itself, because these
are the concepts that power your domain, which takes us to next topic.&lt;/p>
&lt;pre>&lt;code>NOTE: Be careful to use Foreign Keys with CASCADE DELETE. They are very convenient,
but they can massively obscure things and also delete thing you don't want to
delete. Again, better to have the knowledge backed in your program.
&lt;/code>&lt;/pre>
&lt;h3 id="soft-deletes-obscure-businessdomain-logic">Soft Deletes obscure business/domain logic&lt;/h3>
&lt;p>There are some things in your domain or problem space that will require careful
consideration when it comes to deletion. For instance, in my current company
we offer finance to customers based on something we call a Finance Plan. A finance
plan is just a set of constraints that define the details of a loan (duration, rate,
minimal payment, etc).&lt;/p>
&lt;p>Finance plans are then referenced by our applications (these represent credit
applications from customers).&lt;/p>
&lt;p>So, natural question. Should we be able to delete finance plans? Not if we have created
an application with it. Because the finance plan tied to an application now needs
to be kept for historical reasons. We can go even further? Should we be able to
modify finance plans? No, because any modification to a finance plan would be really
a new finance plan. We don&amp;rsquo;t want to be changing the number of months of an already
approved application, right? If it was approved with 12 months, we can&amp;rsquo;t change that to
13.&lt;/p>
&lt;p>Now, what happens when we want to decommission a finance plan? This means, we
want to prevent it for being displayed so applications cannot use it? We just simply take that
concept and convert it into a business action, and we add a column on the database
to track that (&lt;code>decommissioned_at&lt;/code>). This would work very similarly to the soft
delete column, but now the business action is transparent. It is not a delete,
it is a decommission. And it is not in every entity, just on those that need it.&lt;/p>
&lt;p>When we just blindly make everything soft-deletable we obscure these distinctions
and encourage developers to not think about these and other similar issues. This
hinders domain modelling, as we are thinking more on a CRUD approach rather that
a complex domain.&lt;/p></content></item><item><title>Taming Incidental Complexity in Software Development</title><link>https://blog.mnavarro.dev/posts/taming-incidental-complexity/</link><pubDate>Sun, 10 Apr 2022 17:00:00 +0100</pubDate><guid>https://blog.mnavarro.dev/posts/taming-incidental-complexity/</guid><description>Software development is a complex trade. Layers of abstraction, tooling, patterns, tradeoffs, dependencies, people, are some of the reasons behind hard things in Software development. But there is also a big source of complexity: ourselves and our poor choices.
Incidental complexity is the technical term for this kind of complexity. It is defined as anything in software that is hard but really does not need to be. It&amp;rsquo;s when we shoot ourselves in the foot and make our lives harder for no reason.</description><content>&lt;p>Software development is a complex trade. Layers of abstraction, tooling, patterns,
tradeoffs, dependencies, people, are some of the reasons behind hard things in
Software development. But there is also a big source of complexity: ourselves
and our poor choices.&lt;/p>
&lt;p>Incidental complexity is the technical term for this kind of complexity. It is
defined as anything in software that is hard but really does not need to be. It&amp;rsquo;s
when we shoot ourselves in the foot and make our lives harder for no reason.&lt;/p>
&lt;p>Almost every single project or company out there has some degree of incidental
complexity in it. I&amp;rsquo;ve seen plenty of it myself and also caused a good deal of it too.
I&amp;rsquo;ve analyzed it and try to understand its sources by talking to people, asking
questions and seeking to understand the historical developments behind a system
or company.&lt;/p>
&lt;p>After some study, I have come up with some suggestions to avoid shooting ourselves
in the foot regarding making things complex.&lt;/p>
&lt;h2 id="avoid-coupling">Avoid Coupling&lt;/h2>
&lt;p>Almost every single mess of a system finds itself in that state of messyness due
to coupling. Coupling, in my opinion, is the most dangerous thing in Software
Development. It&amp;rsquo;s like a camouflaged predator waiting to strike his prey: you
never see it until is too late.&lt;/p>
&lt;p>Part of the reason why we don&amp;rsquo;t see it, is because coupling is not a bad thing in
and of itself. What I mean by this is that coupling two things together is not a
sufficient requirement for disaster. It is a necessary one, of course, but not
enough by itself. The missing ingredient in the mix is &lt;em>change&lt;/em>. Coupling
only shows his nasty face when one of the things that have been coupled changes.&lt;/p>
&lt;p>This makes identifying coupling something rather tricky, and you don&amp;rsquo;t usually
realize you are making a mistake until something is hard to change. And it may be
that even when that happens, you rationalize it by blaming it to some other external
factor (&amp;ldquo;Oh the client keeps changing the requirements&amp;rdquo;). But truth is that we
have brought that upon ourselves by making our software hard to change.&lt;/p>
&lt;p>When you are building something, at all times you need to ask yourself the
question: &amp;ldquo;Is this coupled to something?&amp;rdquo; and if it is, &amp;ldquo;Is this thing likely to
change?&amp;quot;, and it if is, &amp;ldquo;How costly would it be to change it?&amp;rdquo; Those are some
of the most important questions you can ask yourself when you are building something.&lt;/p>
&lt;p>Wether you couple your application to a particular database engine (I&amp;rsquo;m talking
of you, Active Record), or couple your code by using inheritance instead of
composition, or couple your suite of microservices using REST instead of an
event driven approach, you are going to have a hard time when things have to change.
And if things change, you will pay the price of that change. There is no escape.&lt;/p>
&lt;p>Systems do not need to be coupled. It is mostly our naiveness and inexperience
that causes a system to be a tangled, hard to change mess. Keep an eye on what
is coupled to what and have measures in place to remedy or mitigate the impact
of a change.&lt;/p>
&lt;h2 id="avoid-over-engineering">Avoid Over-Engineering&lt;/h2>
&lt;p>Over engineering is the habit of solving a problem with more engineering than
necessary to solve it. In other words, when a simpler approach would have been
possible to solve a problem but instead a more complex way is preferred.&lt;/p>
&lt;p>This is particularly true of code generation tools. There is a lot of value in
generating boilerplate code, don&amp;rsquo;t get me wrong. But this is usually what an IDE
is for. In my experience, there have been very few times in which I have felt
the burden of writing a class by hand. True, it would have been nice to been
able to autogenerate code from a spec or something in that moment, but that feeling
quickly evaporates when I remember that autogenerated code is often opinionated,
ugly and outdated.&lt;/p>
&lt;p>As a side note, I think that abstraction over code generation is a better
approach to solve the problem of writing less code. Metaprogramming is an excellent
approach for these kinds of problems. Although one can argue that writing code
that leverages metaprogramming is inherently complex, the end result ends
up being a simpler api surface. So yeah, it is hard to do, but easy to use! I would
say that is exactly the goal. Code generation tooling is hard to write, and not
as easy to use (both the tool to generate the code and the generated code itself).&lt;/p>
&lt;p>But, there is a world of difference in considering to autogenerate code for a
massive api than when you have to do it for a really small one. I still remember
the frustration I experienced when I was forced to setup autogeneration for all
the models of an integration I was building, even when many of them had two fields
at most! It took me more time to setup all the autogeneration fluff than it would
have taken me to write the models by hand. But well, the policy in that project
was to do it that way.&lt;/p>
&lt;p>When there is a simpler way of achieving the same end result, go that route. Don&amp;rsquo;t
try to get clever just for the sake of it. Yeah, sounds pretty cool to write your
own routing library for this project, but, do you really need to do that?&lt;/p>
&lt;p>Testing is another source of over-engineering. People build these stateful mock
servers because apparently they need to test third party apis using the HTTP protocol, as
if someone would not have tested that already. In memory mocks are much simpler
and don&amp;rsquo;t cause you the pain of setting up extra dependencies every time you want
to test your application.&lt;/p>
&lt;p>Simplicity is a rare jewel these days, not just because it is hard to find, but because
sometimes it disguises itself as its shallow cousin: convenience. But simplicity tends
to be found there where pragmatism trumps dogmatism. Make sure you are focused
on practical stuff when solving a problem, and no over theorizing it and trying
to justify complex approaches based on remote possibilities.&lt;/p>
&lt;h2 id="avoid-centralizing">Avoid Centralizing&lt;/h2>
&lt;p>Organizations and systems evolve over time, and grow more and more complex. This
is natural and expected. What is not natural or expected is that, sometimes,
we want to tame that growing complexity (that is, make it easier to manage) by
use some form of centralized solution.&lt;/p>
&lt;p>The problem with centralized solutions, especially in distributed systems or
companies, is that by claiming a global benefit, they cause specific harm.
Centralized solutions remove autonomy and create friction. They operate by
removing the control of something from the subsystem or department where its
function is defined, takes place and evolves, toward some central place that
blurs the particulars. This dramatically impacts further development of the
thing of which control has ben surrendered.&lt;/p>
&lt;p>Take software documentation, for instance. Companies choose to centralize
documentation in a single place (a company Wiki or something else) usually
do so by building a narrative of the benefit of having all knowledged in a
cental place of convenient &lt;em>access&lt;/em>, but at the cost of affecting the &lt;em>writing&lt;/em>
of the documentation itself. Often times, due to the distance between the
owner of the documentation (the code repository) and the central Wiki, these former
ends up being completely outdated and seldom used.&lt;/p>
&lt;p>There are other ways in which centralizing is extremely dangerous. The central
part becomes critical and a potential single point of failure or trouble. This
happens with a central database used by many microservices services, or a central
service where every business action has to go check something before anything
else happens (think of centralized access control platforms).&lt;/p>
&lt;p>I think that as long as this central thing is disposable or invisible, then it
is a good central thing. In other words, when the central thing is not the source
of truth because the truth originated somewhere else. Think about git, for instance.
It has a central repository that everyone uses to coordinate, but the changes
and the work happen in your local machine and then you push them, causing that
at least one person has always an up to date copy of what is in the central
repository.&lt;/p>
&lt;p>Same thing with documentation. If we need a place to solve the problem of
information visibility, then let&amp;rsquo;s solve only that problem. What prevents us
from having an automated process push the documentation of a repository
to this central wiki, instead of writing it in a separate place? The problem is not
the writing of the documentation, so why that has to change? The real problem
is the visibility of it: let&amp;rsquo;s make it visible, without removing ownership (More
about this in the next topic).&lt;/p>
&lt;p>When centralizing something, make it work as a repository. Not as the source
of truth (this is, change), but as the place where all the changes made elsewhere
go. Every technology that has any sort of centralized repository works this way:
docker, composer, npm, git. Changes happen next to their source, and then they
are published for the rest of the world.&lt;/p>
&lt;p>If you make the repository the place where things change, then you are going to
have a hard time keeping it in sync with the actual thing that changes. Synching
is an added pain that you don&amp;rsquo;t need to bear. It is incidental complexity.&lt;/p>
&lt;h2 id="avoid-solving-pseudo-problems">Avoid Solving Pseudo-Problems&lt;/h2>
&lt;p>I call pseudo-problems to problems that are not clearly stated. You see, most of
what people call problems are just a preferred approach over a small friction that
usually touches the real problem but it does not address it completely.&lt;/p>
&lt;p>Take this centralized wiki as an example. If the problem is access to the
information, then solve just that problem. If you force everyone to write documentation
far from the system that documents, it&amp;rsquo;s going to cause another problem.&lt;/p>
&lt;p>Problems need to be clearly stated before solved. Otherwise you might be solving
the wrong problem, or even worse, apparently solving the problem but causing
others in the process.&lt;/p>
&lt;p>This is too familiar a story, and it is such a painful one. An organization
has a monolith that is coupled, hard to change, buggy, hard to make sense of, all
the possible bad things that can happen with a monolithic system. Then someone
comes and say &amp;ldquo;We need to split this into microservices&amp;rdquo;, and then they proceed
to break the components of such monolith into different REST apis. So, say that
it was an e-commerce application. Now we have an orders service, a customers service,
a fulfillment service, a payment service, and so on.&lt;/p>
&lt;p>Nice! Every microservice responsibility is now clearly delineated. I would say
that is a win, right?&lt;/p>
&lt;p>Well, if you think about it, maybe not. What was the initial problem? Was that
the responsibilities of the monolith were not clearly defined? Maybe. Was it
the main problem? I don&amp;rsquo;t think so.&lt;/p>
&lt;p>When software is hard to change, it is usually due to coupling. Back to point one
here. Did they solved the coupling? I don&amp;rsquo;t think so. Now services are coupled via
a network protocol (and not an in-memory routine), changes are less transparent (different
teams work on different services now) and changing one service would impact the
other in ways that are harder to spot (now we rely more in logging). I would
argue that this left them in a worse place, as managing changes across teams and
distributed deployable units is harder than in a traditional in-memory application.&lt;/p>
&lt;p>The solution should have really been refactoring the initial application slowly
to take care of the technical debt that made it hard to change and reason about.&lt;/p>
&lt;p>This happens way too often, and with many things. People throw tech at problems, not
engineering. As a result, they think they solved a problem when what they really
did is just go around it and create some more in the process.&lt;/p>
&lt;p>The only way I&amp;rsquo;ve found to fight this insanity is to refuse to solve a problem
until it is clearly stated and demonstrated it is a problem and why. Only then
a reasonable discussion about potential solutions and their benefits and
drawbacks can happen. Solving the wrong problem is one of the worst sources
of incidental complexity.&lt;/p>
&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>Well there you have it. Another of those rants. Hopefully it saves you
a trouble or two.&lt;/p></content></item></channel></rss>