<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Multitenancy on The Chilean Nerd</title><link>https://mnavarro.dev/tags/multitenancy/</link><description>Recent content in Multitenancy on The Chilean Nerd</description><generator>Hugo -- gohugo.io</generator><language>en-GB</language><copyright>Â©2019 Matias Navarro Carter. CC-BY-SA.</copyright><lastBuildDate>Sun, 06 Jun 2021 00:00:00 +0100</lastBuildDate><atom:link href="https://mnavarro.dev/tags/multitenancy/index.xml" rel="self" type="application/rss+xml"/><item><title>Preventing tenant pollution in multitenant applications</title><link>https://mnavarro.dev/posts/tenant-pollution/</link><pubDate>Sun, 06 Jun 2021 00:00:00 +0100</pubDate><guid>https://mnavarro.dev/posts/tenant-pollution/</guid><description>Last year I built a multitenant system for my employer Spatialest. It was my first time doing a multitenant system, so I researched a lot before doing it. I studied carefully the experience of platforms like Shopify, as their multi tenant requirements were similar to ours. But even after some careful study, I made some mistakes.
One of those mistakes is what I&amp;rsquo;ve come to call tenant pollution. This means that many services or routines need the tenant as an argument in order to do something.</description><content>&lt;p>Last year I built a multitenant system for my employer Spatialest. It was my first time doing a multitenant system, so I researched a lot before doing it. I studied carefully the experience of platforms like Shopify, as their multi tenant requirements were similar to ours. But even after some careful study, I made some mistakes.&lt;/p>
&lt;p>One of those mistakes is what I&amp;rsquo;ve come to call &lt;strong>tenant pollution&lt;/strong>. This means that many services or routines need the tenant as an argument in order to do something. This causes the tenant or the tenant unique identifier to be passed around many layers of the codebase. Basically, the tenant was &lt;strong>everywhere&lt;/strong> in the code.&lt;/p>
&lt;p>For example, this is a small part of our filesystem interface:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-php" data-lang="php">&lt;span style="color:#75715e">&amp;lt;?php&lt;/span>
&lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">Filesystem&lt;/span>
{
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">put&lt;/span>(&lt;span style="color:#a6e22e">string&lt;/span> $tenantId, &lt;span style="color:#a6e22e">string&lt;/span> $path, &lt;span style="color:#a6e22e">StreamInterface&lt;/span> $contents)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">void&lt;/span>;
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">get&lt;/span>(&lt;span style="color:#a6e22e">string&lt;/span> $tenantId, &lt;span style="color:#a6e22e">string&lt;/span> $path)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">StreamInterface&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The implementation contains a &lt;code>TenantProvider&lt;/code> that can use the tenant id to retrieve information about the tenant and use that information to determine the folder name where all the tenant files should be stored.&lt;/p>
&lt;p>All of our services are pretty much similar. Here is another example of the &lt;code>EmailFactory&lt;/code>, that creates email messages.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-php" data-lang="php">&lt;span style="color:#75715e">&amp;lt;?php&lt;/span>
&lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">EmailFactory&lt;/span>
{
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">create&lt;/span>(&lt;span style="color:#a6e22e">string&lt;/span> $tenantId, &lt;span style="color:#a6e22e">string&lt;/span> $messageName, &lt;span style="color:#66d9ef">array&lt;/span> $data &lt;span style="color:#f92672">=&lt;/span> [])&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Email&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The approach is pretty much similar to the filesystem one. We pass the tenant so we can fetch their settings. With the settings, we will created custom branded emails for our tenant with their corporate logos and images.&lt;/p>
&lt;p>I have to say that when I was implementing all these services I sort of smelled this. Didn&amp;rsquo;t liked it, but I preferred to the alternative of shared internal service state. And there is nothing I am more against than that. It is terrible OOP.&lt;/p>
&lt;p>Many developers would do this. They will remove the tenant and pass it to a setter in the service.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-php" data-lang="php">&lt;span style="color:#75715e">&amp;lt;?php&lt;/span>
&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ConcreteEmailFactory&lt;/span>
{
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">setTenant&lt;/span>(&lt;span style="color:#a6e22e">Tenant&lt;/span> $tenant)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">void&lt;/span>
{
$this&lt;span style="color:#f92672">-&amp;gt;&lt;/span>&lt;span style="color:#a6e22e">tenant&lt;/span> &lt;span style="color:#f92672">=&lt;/span> $tenant;
}
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">create&lt;/span>(&lt;span style="color:#a6e22e">string&lt;/span> $messageName, &lt;span style="color:#66d9ef">array&lt;/span> $data &lt;span style="color:#f92672">=&lt;/span> [])&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Email&lt;/span>
{
&lt;span style="color:#75715e">// Do the action.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> }
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>But, once you set the tenant state you could run into all sorts of undesired side effects. PHP does not make this very obvious, due to the fact that when executed in CGI mode all the state is regenerated across requests. But when you are using React PHP or spinning workers in Road Runner, that&amp;rsquo;s when it bites you. If you move to other languages you cannot and must not do this. PHP should not be the exception.&lt;/p>
&lt;p>But I sort of had a realization when working in the frontend with React and other frameworks. You see, state in frontend is everywhere. Everything is side-effecty and built around state. Frontend developers live with this reality all the time. It teaches them not to &lt;em>fear&lt;/em> state, but to tame it and manage it properly. This is the reason why React&amp;rsquo;s &lt;code>useEffect&lt;/code> hook exists.&lt;/p>
&lt;p>I asked myself. Okay, shared state stored in a service is bad but, is there a way in which I could control it, or tame it?&lt;/p>
&lt;p>I said, first, let&amp;rsquo;s acknowledge it&amp;rsquo;s existence in an interface:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-php" data-lang="php">&lt;span style="color:#75715e">&amp;lt;?php&lt;/span>
&lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">TenantState&lt;/span>
{
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">initialize&lt;/span>(&lt;span style="color:#a6e22e">Tenant&lt;/span> $tenant)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">void&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now, how can unset that initialized state so I avoid side effects? Like &lt;code>useState&lt;/code> in React works: I will return a &lt;code>callable&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-php" data-lang="php">&lt;span style="color:#75715e">&amp;lt;?php&lt;/span>
&lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">TenantState&lt;/span>
{
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">initialize&lt;/span>(&lt;span style="color:#a6e22e">Tenant&lt;/span> $tenant)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">callable&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This is how it would look in the email factory:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-php" data-lang="php">&lt;span style="color:#75715e">&amp;lt;?php&lt;/span>
&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ConcreteEmailFactory&lt;/span>
{
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">initialize&lt;/span>(&lt;span style="color:#a6e22e">Tenant&lt;/span> $tenant)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">callable&lt;/span>
{
$this&lt;span style="color:#f92672">-&amp;gt;&lt;/span>&lt;span style="color:#a6e22e">tenant&lt;/span> &lt;span style="color:#f92672">=&lt;/span> $tenant;
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> () {
$this&lt;span style="color:#f92672">-&amp;gt;&lt;/span>&lt;span style="color:#a6e22e">tenant&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
};
}
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">create&lt;/span>(&lt;span style="color:#a6e22e">string&lt;/span> $messageName, &lt;span style="color:#66d9ef">array&lt;/span> $data &lt;span style="color:#f92672">=&lt;/span> [])&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Email&lt;/span>
{
&lt;span style="color:#75715e">// Do the action.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> }
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The secret is this: when executed, the callable will leave the class in it&amp;rsquo;s original state. Now, you can group a bunch of these services into a composite initializer and have a single place in your code where you will initialize all the tenant state, group the callables to unset the state, and then return them.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-php" data-lang="php">&lt;span style="color:#75715e">&amp;lt;?php&lt;/span>
&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CompositeTenantState&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> &lt;span style="color:#a6e22e">TenantState&lt;/span>
{
&lt;span style="color:#e6db74">/** @param TenantState[] $states **/&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">array&lt;/span> $states;
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> __construct(&lt;span style="color:#a6e22e">TenantState&lt;/span> &lt;span style="color:#f92672">...&lt;/span>$states)
{
$this&lt;span style="color:#f92672">-&amp;gt;&lt;/span>&lt;span style="color:#a6e22e">states&lt;/span> &lt;span style="color:#f92672">=&lt;/span> $states;
}
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">initialize&lt;/span>(&lt;span style="color:#a6e22e">Tenant&lt;/span> $tenant)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">callable&lt;/span>
{
$unsets &lt;span style="color:#f92672">=&lt;/span> [];
&lt;span style="color:#66d9ef">foreach&lt;/span> ($this&lt;span style="color:#f92672">-&amp;gt;&lt;/span>&lt;span style="color:#a6e22e">states&lt;/span> &lt;span style="color:#66d9ef">as&lt;/span> $state) {
$unsets[] &lt;span style="color:#f92672">=&lt;/span> $state&lt;span style="color:#f92672">-&amp;gt;&lt;/span>&lt;span style="color:#a6e22e">initialize&lt;/span>($tenant);
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> () &lt;span style="color:#66d9ef">use&lt;/span> ($unsets) {
&lt;span style="color:#66d9ef">foreach&lt;/span> ($unsets &lt;span style="color:#66d9ef">as&lt;/span> $unset) {
$unset();
}
};
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>You implement &lt;code>TenantState&lt;/code> in every service that needs the tenant, and you pass it to this composite implementation.&lt;/p>
&lt;p>This approach is great. If you are using middleware, you can initialize all the tenant state early in the pipeline, and then, when the request has finished, you unset all the state you have set. It is useful also for centralizing initialization of many services at once, so if you need to run the same logic in a console command, you can set up all the services for a tenant and use them freely.&lt;/p>
&lt;p>I wish I could have done this since the beginning. Object graphs would be simpler and methods shorter. Well, I guess you never cease to learn.&lt;/p></content></item></channel></rss>