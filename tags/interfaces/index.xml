<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Interfaces on The Chilean Nerd</title><link>https://blog.mnavarro.dev/tags/interfaces/</link><description>Recent content in Interfaces on The Chilean Nerd</description><generator>Hugo -- gohugo.io</generator><language>en-GB</language><copyright>Â©2019 Matias Navarro Carter. CC-BY-SA.</copyright><lastBuildDate>Mon, 07 Jun 2021 00:00:00 +0100</lastBuildDate><atom:link href="https://blog.mnavarro.dev/tags/interfaces/index.xml" rel="self" type="application/rss+xml"/><item><title>Why Go Interfaces Are Awesome</title><link>https://blog.mnavarro.dev/posts/why-go-interfaces-are-awesome/</link><pubDate>Mon, 07 Jun 2021 00:00:00 +0100</pubDate><guid>https://blog.mnavarro.dev/posts/why-go-interfaces-are-awesome/</guid><description>After a couple of months of using Go commercially (I&amp;rsquo;ve been learning it from about a year now) I can finally have an understanding of the language and the reasoning behind some of the decisions the language authors made when drafting and designing the language.
One of these is interfaces.
Interfaces in Go are quite special, and they are by far my most loved feature of the language. It is not that I don&amp;rsquo;t know that other languages have interfaces, but they way Go implements them is truly unique and honestly really awesome.</description><content>&lt;p>After a couple of months of using Go commercially (I&amp;rsquo;ve been learning it from about a year now) I can finally have an understanding of the language and the reasoning behind some of the decisions the language authors made when drafting and designing the language.&lt;/p>
&lt;p>One of these is interfaces.&lt;/p>
&lt;p>Interfaces in Go are quite special, and they are by far my most loved feature of the language. It is not that I don&amp;rsquo;t know that other languages have interfaces, but they way Go implements them is truly unique and honestly really awesome.&lt;/p>
&lt;p>Here is why.&lt;/p>
&lt;h2 id="go-interfaces-are-behavioral-only">Go interfaces are behavioral-only&lt;/h2>
&lt;p>This is something some languages get right too, like PHP. But others like Java or Typescript allow you to define state (properties) in your interfaces too.&lt;/p>
&lt;p>Interfaces should always deal with behavior. Any state, property or any other thing there is really about an implementation detail and should not belong in the interface at all.&lt;/p>
&lt;p>This is how you define an interface in Go:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">money&lt;/span>
&lt;span style="color:#75715e">// A Converter takes a pointer to Money and returns another pointer to a
&lt;/span>&lt;span style="color:#75715e">// converted Money, or an error.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Converter&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;span style="color:#a6e22e">Convert&lt;/span>(&lt;span style="color:#a6e22e">amount&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Money&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Money&lt;/span>, &lt;span style="color:#66d9ef">error&lt;/span>)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>There is nothing here about state nor any implementation detail. An interface is just a set of methods with a predefined signature.&lt;/p>
&lt;h2 id="go-interfaces-are-implicit">Go interfaces are implicit&lt;/h2>
&lt;p>Now, how do I make a type in Go implement the interface declared above? Simply, by providing that the type in question has the methods defined by the interface with the exact same signature.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">converter&lt;/span>
&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">FixedConverter&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#a6e22e">rate&lt;/span> &lt;span style="color:#66d9ef">float64&lt;/span>
}
&lt;span style="color:#75715e">// This FixedConverter implements the Converter interface.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">FixedConverter&lt;/span>) &lt;span style="color:#a6e22e">Convert&lt;/span>(&lt;span style="color:#a6e22e">amount&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Money&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Money&lt;/span>, &lt;span style="color:#66d9ef">error&lt;/span>) {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">amount&lt;/span>.&lt;span style="color:#a6e22e">Times&lt;/span>(&lt;span style="color:#a6e22e">rate&lt;/span>), &lt;span style="color:#66d9ef">nil&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Note that, a difference with other languages is that we never wrote any &lt;code>implements&lt;/code> nor we referenced he interface type &lt;code>Converter&lt;/code> inside our &lt;code>converter&lt;/code> package. Implementation in Go is &lt;strong>implicit&lt;/strong>. You don&amp;rsquo;t explicitly implement an interface: any type that has the method(s) of the interface implements that interface and becomes a Liskov-Substitutable value.&lt;/p>
&lt;h2 id="go-interfaces-are-zero-coupled">Go interfaces are zero-coupled&lt;/h2>
&lt;p>Now, due to this particular property of Go interfaces, we don&amp;rsquo;t need to have a reference to the package where the interface type is defined. Which means that we achieve a zero coupling between the package that uses the interface and the package that implements the interface. Not low coupling: zero.&lt;/p>
&lt;p>It&amp;rsquo;s common in other languages like Java or PHP, to have packages containing mostly if not exclusively interfaces. Think about JPA in Java or all the PSRs in PHP. The idea behind this practice is that you only have to couple to the contracts, but not to the implementations, which is a massive gain in decoupling. But in Go interfaces, you don&amp;rsquo;t even have to include the interface package. You can just create another interface in your own package with the same signature and
have your code use that.&lt;/p>
&lt;p>This means that libraries now are free to define their own apis and there is not much need for defining a common contract. The code that defines the contract is the code you write, and not some third party.&lt;/p>
&lt;p>This is very powerful.&lt;/p></content></item></channel></rss>