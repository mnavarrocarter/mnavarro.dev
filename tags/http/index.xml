<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>HTTP on The Chilean Nerd</title><link>https://mnavarro.dev/tags/http/</link><description>Recent content in HTTP on The Chilean Nerd</description><generator>Hugo -- gohugo.io</generator><language>en-GB</language><copyright>Â©2019 Matias Navarro Carter. CC-BY-SA.</copyright><lastBuildDate>Wed, 08 Sep 2021 20:00:00 +0100</lastBuildDate><atom:link href="https://mnavarro.dev/tags/http/index.xml" rel="self" type="application/rss+xml"/><item><title>Testing HTTP SDKs in Golang</title><link>https://mnavarro.dev/posts/http-sdk-testing-in-go/</link><pubDate>Wed, 08 Sep 2021 20:00:00 +0100</pubDate><guid>https://mnavarro.dev/posts/http-sdk-testing-in-go/</guid><description>How do you test code that integrates with a third party HTTP service?
The Philosophical Answer If you think about it, it is not an easy question to answer. Maybe you have already some strong opinions formed about it. But, in my experience, answers to this question differ greatly among developers, even between seasoned ones.
I believe those differences are due to some preconceived ideas or different definitions about what testing is.</description><content>&lt;p>How do you test code that integrates with a third party HTTP service?&lt;/p>
&lt;h1 id="the-philosophical-answer">The Philosophical Answer&lt;/h1>
&lt;p>If you think about it, it is not an easy question to answer. Maybe you have already some strong opinions formed about it. But, in my experience, answers to this question differ greatly among developers, even between seasoned ones.&lt;/p>
&lt;p>I believe those differences are due to some preconceived ideas or different definitions about what testing is. For example, some people believe that testing is making sure your code works. The problem with that definition is that it is too vague; &amp;ldquo;it works&amp;rdquo; can mean anything.&lt;/p>
&lt;figure class="left" >
&lt;img src="https://blog.sergeyev.info/images/works-on-my-machine/the-line.jpg" />
&lt;/figure>
&lt;p>Take, for instance, the following (too familiar) situation: you are told to code a service (or SDK) that integrates with a third party api or http service. As is usual with integrations, confusing or incomplete specs are passed around. Nonetheless, that is sufficient to do your job. You decide to test creating a mock server based on the spec and build your suite to a very good coverage. So far so good.&lt;/p>
&lt;p>But, when the day comes to do some acceptance testing against the QA environment of the service you are integrating to, you realized nothing worked. Turns out services needed an extra header that was not included in any spec. No problem though; you add it to the code, update your tests and move forward.&lt;/p>
&lt;p>I&amp;rsquo;ll come back to this story to explore other relevant topics later. For now, I want to use it to ask you a question. Would you say that the initial version released to test against QA &amp;ldquo;worked&amp;rdquo;? Well, it&amp;rsquo;s a tricky one, isn&amp;rsquo;t it? It did not worked in the sense that it did not integrate correctly because of the missing header. It worked in the sense that the program did what it was coded to do with the available knowledge at the time.&lt;/p>
&lt;p>Based on this, I would like to make the main point of this article, from which every other point flows. &lt;strong>Testing is not making sure your program does something correctly; testing is making sure your program does what the code says it does.&lt;/strong> In our previously mentioned story, we cannot ensure a correct integration until we have hit a real service (and not a mock), but we can have good tests that ensure the program is doing what we have coded it to do.&lt;/p>
&lt;p>I think the distinction of these two is greatly accentuated in integrations with third party http services. Unless you have an spec that is automatically generated from the service code, until you start hitting endpoints, you can never know for sure if you have integrated correctly or not.&lt;/p>
&lt;p>In my opinion, the sooner we embrace this reality, the better. Once we do, we will be able to go and ask ourselves the next question.&lt;/p>
&lt;h2 id="what-then-do-we-test">What then do we test?&lt;/h2>
&lt;p>So, if we cannot test that our SDK integrates correctly with the service. What do we test then? The answer is: &lt;strong>we test that our code follows what we understand of the specification we were given.&lt;/strong>&lt;/p>
&lt;p>For instance, if the specification says that we should send an &lt;code>Authorization&lt;/code> header with some sort of token, we test that (1) A request is created containing the &lt;code>Authorization&lt;/code> header and (2) that the passed token value is indeed the same that is injected in the header. Similar principles follow for URL, method and body.&lt;/p>
&lt;p>The following of a specification does not have only to do with the expectations about a request, but also with the correct handling of a response. This means we should also test that our code follows the specification when handling responses.&lt;/p>
&lt;p>We should map status codes to certain errors, or react to different content types, or deserialize certain payloads to some types without data loss, etc. We should test that our code does this based on the spec.&lt;/p>
&lt;p>Okay, I&amp;rsquo;m sure you are getting very impatient and want to get to the &amp;ldquo;how&amp;rdquo; of testing a third party http integration. Just allow me to say one more thing.&lt;/p>
&lt;h2 id="what-are-we-not-testing">What are we not testing?&lt;/h2>
&lt;p>Many developers understand all that I&amp;rsquo;ve written. So, they take their keyboards and decide that the best way to test the aforementioned things is just by spinning up a temporary web server process, listening in a random port, that is pre-configured to respond to requests mapping certain methods and urls to certain responses. Most people call this a &lt;em>mock server&lt;/em>.&lt;/p>
&lt;p>No blame on them! I&amp;rsquo;ve seen this approach being endorsed by &lt;a href="https://youtu.be/rWBSMsLG8po?t=2413">really prominent Go developers&lt;/a>. And I think it is specially prominent in Go due to the fact that it is indeed very easy to spin up a server in a separate Goroutine.&lt;/p>
&lt;p>However, this approach is often unnecessary and overly complex. Let me explain why.&lt;/p>
&lt;h3 id="we-are-not-testing-tcptlshttp">We are not testing TCP/TLS/HTTP!&lt;/h3>
&lt;p>First, there is no need to send our &lt;code>*http.Request&lt;/code> over a TCP socket to a server, have the server parse the request and end up with a &lt;code>*http.Request&lt;/code> again in a completely different process, that then will be passed to a handler that will match our request and return a response.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-txt" data-lang="txt">http.Request --&amp;gt; Http Client --&amp;gt; TCP Socket --&amp;gt; Server --&amp;gt; Http Parser --&amp;gt; http.Request --&amp;gt; handler -&amp;gt; http.Response
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We can simplify this massively, bypassing all the TCP, server stuff and just doing things in memory, for instance, in a function.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-txt" data-lang="txt">http.Request -&amp;gt; function -&amp;gt; http.Response
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And this is fine, because we are not testing TCP, nor TLS, nor the HTTP protocol. The Go standard library already has tests for all those packages and functions. We want to test &lt;em>our&lt;/em> code.&lt;/p>
&lt;p>In order for us to test that our code complies to a spec, there is no need then to spin up a web server.&lt;/p>
&lt;p>Plus, if something happens with that server, it will be really hard to debug.&lt;/p>
&lt;h3 id="we-are-not-testing-routing">We are not testing routing!&lt;/h3>
&lt;p>Even when not using server-over-TCP mocking techniques, but in-memory ones, some people still go with building some kind of in-memory testing &amp;ldquo;server&amp;rdquo; that returns responses based on some matching logic. Usually this takes the form of matching the method and the url.&lt;/p>
&lt;p>Again, this is completely unnecessary, and it could lead to undesirable side-effects in testing, plus a couple of more issues.&lt;/p>
&lt;p>It is unnecessary because, remember, we are testing that our code conforms to a spec. In other words, we are testing that we send a request with the correct contents and that we are capable to handle certain responses. We are not testing routing (that a request with a certain method and URL with gives us a certain response).&lt;/p>
&lt;p>This approach usually leads to side effects. Since this massive, respond-to-everything, in-memory mock of a server needs to be configured somewhere, it usually is outside the tested code. If someone changes an id, or accidentally creates another request with the same url there is potential breakage.&lt;/p>
&lt;p>Also, there is no clear contract regarding to what should be the response when a request of this mock cannot be matched. This usually weakens error handling code.&lt;/p>
&lt;p>Finally, a mock like this ignores the fact that some HTTP operations are not idempotent: the same method and url combination can and will give different answers based on the internal state of the server at the time of the call. It is really hard to mock that using this approach.&lt;/p>
&lt;p>It&amp;rsquo;s better not to try to play any matching games and do something deterministic and straightforward.&lt;/p>
&lt;h1 id="the-practical-answer">The Practical Answer&lt;/h1>
&lt;p>Now that I have ranted enough about these things, is time I explain my proposed approach.&lt;/p>
&lt;p>Let&amp;rsquo;s suppose that we have an third party service with an endpoint &lt;code>POST /input&lt;/code>. This endpoint takes a &lt;code>application/json&lt;/code> payload that only contains
one key &lt;code>message&lt;/code>, and can be an string of any length.&lt;/p>
&lt;p>The service returns an &lt;code>application/json&lt;/code> payload with the same structure: again, the object with a &lt;code>message&lt;/code> key.&lt;/p>
&lt;p>This is how I would implement it in Go. Read the comments so you get a better understanding.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">fakesdk&lt;/span>
&lt;span style="color:#75715e">// A main client struct to hold everything together
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">FakeApiClient&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#a6e22e">client&lt;/span> &lt;span style="color:#a6e22e">HTTPClient&lt;/span>
&lt;span style="color:#a6e22e">baseUrl&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
}
&lt;span style="color:#75715e">// A constructor to make that client with good defaults
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">NewFakeApiClient&lt;/span>(&lt;span style="color:#a6e22e">baseUrl&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">FakeApiClient&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">FakeApiClient&lt;/span>{
&lt;span style="color:#a6e22e">client&lt;/span>: &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">DefaultClient&lt;/span>,
&lt;span style="color:#a6e22e">baseUrl&lt;/span>: &lt;span style="color:#a6e22e">baseUrl&lt;/span>
}
}
&lt;span style="color:#75715e">// Some people like to make an interface with the same signature
&lt;/span>&lt;span style="color:#75715e">// as http.Client.Do function so they can swap implementations for
&lt;/span>&lt;span style="color:#75715e">// testing. http.RoundTripper can do this already, but well,
&lt;/span>&lt;span style="color:#75715e">// everyone has their own preference.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">HTTPClient&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;span style="color:#a6e22e">Do&lt;/span>(&lt;span style="color:#a6e22e">req&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">Request&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">Response&lt;/span>, &lt;span style="color:#66d9ef">error&lt;/span>)
}
&lt;span style="color:#75715e">// This creates the request. Pretty standard stuff here.
&lt;/span>&lt;span style="color:#75715e">// The only detail is that we need to serialize from json and make
&lt;/span>&lt;span style="color:#75715e">// sure we put the right content type.
&lt;/span>&lt;span style="color:#75715e">// Oh, and that we pass the context to the request!
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">cl&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">FakeApiClient&lt;/span>) &lt;span style="color:#a6e22e">mustMakeRequest&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span> &lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#a6e22e">method&lt;/span>, &lt;span style="color:#a6e22e">path&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">input&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span>{}) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">Request&lt;/span> {
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">body&lt;/span> &lt;span style="color:#a6e22e">io&lt;/span>.&lt;span style="color:#a6e22e">Reader&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">input&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#a6e22e">b&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">json&lt;/span>.&lt;span style="color:#a6e22e">Marshal&lt;/span>(&lt;span style="color:#a6e22e">input&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
panic(&lt;span style="color:#a6e22e">err&lt;/span>) &lt;span style="color:#75715e">// Developer error
&lt;/span>&lt;span style="color:#75715e">&lt;/span> }
&lt;span style="color:#a6e22e">body&lt;/span> = &lt;span style="color:#a6e22e">bytes&lt;/span>.&lt;span style="color:#a6e22e">NewBuffer&lt;/span>(&lt;span style="color:#a6e22e">b&lt;/span>)
}
&lt;span style="color:#a6e22e">url&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">cl&lt;/span>.&lt;span style="color:#a6e22e">baseUrl&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">path&lt;/span>
&lt;span style="color:#a6e22e">req&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">NewRequest&lt;/span>(&lt;span style="color:#a6e22e">method&lt;/span>, &lt;span style="color:#a6e22e">url&lt;/span>, &lt;span style="color:#a6e22e">body&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
panic(&lt;span style="color:#a6e22e">err&lt;/span>) &lt;span style="color:#75715e">// Developer error
&lt;/span>&lt;span style="color:#75715e">&lt;/span> }
&lt;span style="color:#a6e22e">req&lt;/span>.&lt;span style="color:#a6e22e">Header&lt;/span>.&lt;span style="color:#a6e22e">Add&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Content-Type&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;application/json&amp;#34;&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">req&lt;/span>.&lt;span style="color:#a6e22e">WithContext&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span>)
}
&lt;span style="color:#75715e">// The fake input struct
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">FakeInput&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#a6e22e">Message&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;message&amp;#34;`&lt;/span>
}
&lt;span style="color:#75715e">// The fake output struct
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">FakeOutput&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#a6e22e">Message&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;message&amp;#34;`&lt;/span>
}
&lt;span style="color:#75715e">// This is the actual method that will be used in client code.
&lt;/span>&lt;span style="color:#75715e">// Pretty standard stuff too. Sends the request and handles any error.
&lt;/span>&lt;span style="color:#75715e">// Also decodes the payload.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">cl&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">FakeApiClient&lt;/span>) &lt;span style="color:#a6e22e">PostInput&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span> &lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#a6e22e">input&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">FakeInput&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">FakeOutput&lt;/span>, &lt;span style="color:#66d9ef">error&lt;/span>) {
&lt;span style="color:#a6e22e">req&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">cl&lt;/span>.&lt;span style="color:#a6e22e">mustMakeRequest&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;POST&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;/input&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">input&lt;/span>)
&lt;span style="color:#a6e22e">res&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">cl&lt;/span>.&lt;span style="color:#a6e22e">client&lt;/span>.&lt;span style="color:#a6e22e">Do&lt;/span>(&lt;span style="color:#a6e22e">req&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>
}
&lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#a6e22e">res&lt;/span>.&lt;span style="color:#a6e22e">Body&lt;/span>.&lt;span style="color:#a6e22e">Close&lt;/span>()
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">res&lt;/span>.&lt;span style="color:#a6e22e">StatusCode&lt;/span> &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">400&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>, &lt;span style="color:#a6e22e">errors&lt;/span>.&lt;span style="color:#a6e22e">New&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;server responded with code %d&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">res&lt;/span>.&lt;span style="color:#a6e22e">StatusCode&lt;/span>)
}
&lt;span style="color:#a6e22e">out&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">FakeOutput&lt;/span>{}
&lt;span style="color:#a6e22e">err&lt;/span> = &lt;span style="color:#a6e22e">json&lt;/span>.&lt;span style="color:#a6e22e">NewDecoder&lt;/span>(&lt;span style="color:#a6e22e">res&lt;/span>.&lt;span style="color:#a6e22e">Body&lt;/span>).&lt;span style="color:#a6e22e">Decode&lt;/span>(&lt;span style="color:#a6e22e">out&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">out&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now, the only thing I need to test is that I send the correct request and I&amp;rsquo;m capable to handle all possible responses or eventual socket errors. That&amp;rsquo;s it. Nothing else.&lt;/p>
&lt;p>Sending the the correct request in this case means that the method is correct, the url too, that the body gets serialized to json correctly and that the compulsory headers are present and with the correct values.&lt;/p>
&lt;p>Being capable to handle all possible responses means that I should code expectations for when my code fails. For instance, if I get a response with a status code 400, then my code should return an error saying &amp;ldquo;server responded with code 400&amp;rdquo;.&lt;/p>
&lt;p>Now, doing all these checks on the request and building all the responses for every test case would be very verbose. Luckily, I&amp;rsquo;ve created a package just for that. It is called &lt;code>httpclientmock&lt;/code>. It is extremely simple and straight forward, and you are meant to use it in your test suites like this:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">fakesdk_test&lt;/span>
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">postInputTests&lt;/span> = []&lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;span style="color:#a6e22e">input&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">FakeInput&lt;/span>
&lt;span style="color:#a6e22e">mock&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">httpclientmock&lt;/span>.&lt;span style="color:#a6e22e">Mock&lt;/span>
&lt;span style="color:#a6e22e">assertions&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>, &lt;span style="color:#a6e22e">output&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">FakeOutput&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#66d9ef">error&lt;/span>)
}{
{
&lt;span style="color:#a6e22e">name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;test one&amp;#34;&lt;/span>,
&lt;span style="color:#a6e22e">input&lt;/span>: &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">FakeInput&lt;/span>{&lt;span style="color:#e6db74">&amp;#34;This is a message sent&amp;#34;&lt;/span>},
&lt;span style="color:#a6e22e">mock&lt;/span>: &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">httpclientmock&lt;/span>.&lt;span style="color:#a6e22e">Mock&lt;/span>{
&lt;span style="color:#a6e22e">Expect&lt;/span>: &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">httpclientmock&lt;/span>.&lt;span style="color:#a6e22e">Request&lt;/span>{
&lt;span style="color:#a6e22e">Method&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;POST&amp;#34;&lt;/span>,
&lt;span style="color:#a6e22e">Url&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;https://some.fake.service/input&amp;#34;&lt;/span>,
&lt;span style="color:#a6e22e">Headers&lt;/span>: &lt;span style="color:#66d9ef">map&lt;/span>[&lt;span style="color:#66d9ef">string&lt;/span>]&lt;span style="color:#66d9ef">string&lt;/span>{
&lt;span style="color:#e6db74">&amp;#34;Content-Type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;application/json&amp;#34;&lt;/span>,
},
&lt;span style="color:#a6e22e">Body&lt;/span>: []byte(&lt;span style="color:#e6db74">`{&amp;#34;message&amp;#34;:&amp;#34;This is a message sent&amp;#34;}`&lt;/span>),
},
&lt;span style="color:#a6e22e">Return&lt;/span>: &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">httpclientmock&lt;/span>.&lt;span style="color:#a6e22e">Response&lt;/span>{
&lt;span style="color:#a6e22e">StatusCode&lt;/span>: &lt;span style="color:#ae81ff">200&lt;/span>,
&lt;span style="color:#a6e22e">Headers&lt;/span>: &lt;span style="color:#66d9ef">map&lt;/span>[&lt;span style="color:#66d9ef">string&lt;/span>]&lt;span style="color:#66d9ef">string&lt;/span>{
&lt;span style="color:#e6db74">&amp;#34;Content-Type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;application/json&amp;#34;&lt;/span>,
},
&lt;span style="color:#a6e22e">Body&lt;/span>: []byte(&lt;span style="color:#e6db74">`{&amp;#34;message&amp;#34;:&amp;#34;This is a message received&amp;#34;}`&lt;/span>),
},
},
&lt;span style="color:#a6e22e">assertions&lt;/span>: &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>, &lt;span style="color:#a6e22e">output&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">FakeOutput&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#66d9ef">error&lt;/span>) {
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">output&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Error&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;no output&amp;#34;&lt;/span>)
}
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Error&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;an error has happened&amp;#34;&lt;/span>)
}
},
},
}
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">TestPostInput&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>) {
&lt;span style="color:#a6e22e">client&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">FakeApiClient&lt;/span>{&lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">DefaultClient&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;https://some.fake.service&amp;#34;&lt;/span>}
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">test&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">postInputTests&lt;/span> {
&lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Run&lt;/span>(&lt;span style="color:#a6e22e">test&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span>, &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>) {
&lt;span style="color:#75715e">// Inject in client mutates http.DefaultClient transport.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// The restore function restores the previous transport.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">restore&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span>.&lt;span style="color:#a6e22e">mock&lt;/span>.&lt;span style="color:#a6e22e">InjectInClient&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>)
&lt;span style="color:#75715e">// We defer the restoring of the previous transport when the test finishes
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#a6e22e">restore&lt;/span>()
&lt;span style="color:#75715e">// Pass the input
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">out&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">client&lt;/span>.&lt;span style="color:#a6e22e">PostInput&lt;/span>(&lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Background&lt;/span>(), &lt;span style="color:#a6e22e">test&lt;/span>.&lt;span style="color:#a6e22e">input&lt;/span>)
&lt;span style="color:#75715e">// Assert about the output
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span>.&lt;span style="color:#a6e22e">assertions&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span>, &lt;span style="color:#a6e22e">out&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
})
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The benefits of using this library are huge. First, its ability to modify &lt;code>http.DefaultClient&lt;/code> responsibly means you don&amp;rsquo;t need to worry about dependency injection too much when setting up tests that send requests very deep in the call stack. So, you could use it for E2E tests without a problem.&lt;/p>
&lt;p>If you wish to use better practices like dependency injection, no problem, we got you covered. &lt;code>httptestmock.Mock&lt;/code> has a method called &lt;code>BuildNewClient&lt;/code> that will give you a &lt;code>*http.Client&lt;/code>. You can also call &lt;code>GetTestFunc&lt;/code> and this
will give you a &lt;code>TestHttpFunc&lt;/code>, which is a type that implements &lt;code>http.RoundTripper&lt;/code> and another function that has the same signature than &lt;code>Do&lt;/code> in &lt;code>http.Client&lt;/code>. You can integrate this library into your code in all these ways.&lt;/p>
&lt;p>You are probably thinking &amp;ldquo;Oh this thing modifies the global &lt;code>http.DefaultClient&lt;/code>. That could cause massive side effects&amp;rdquo; And yes, you are correct. This is why &lt;code>InjectInClient&lt;/code> returns a function. Calling it will restore the state of the client to what it was before the test. And you must make sure to defer that, so no other tests can potentially be affected by the mutation.&lt;/p>
&lt;p>You can keep on adding more tests in the block, with different payloads and different responses, writing expectations for every case. All the information of the test is in the test itself. No need to chase other files or look in logs from another process.&lt;/p>
&lt;p>Also, no side effects. All the state of the world lives there in your test run. Your response will be what the &lt;code>Return&lt;/code> property indicates will be. No surprises. That&amp;rsquo;s how a test should be.&lt;/p>
&lt;h2 id="learn-by-looking">Learn By Looking&lt;/h2>
&lt;p>If you need a more comprehensive example. You can take a look at &lt;a href="https://github.com/mnavarrocarter/transbank">this library I&amp;rsquo;m building&lt;/a>. It&amp;rsquo;s an SDK for a third party http service from Chile called Transbank. One of its services, Webpay, allows you to integrate with their payment gateway. &lt;a href="https://github.com/mnavarrocarter/transbank/blob/main/webpay/create_test.go">I&amp;rsquo;m using &lt;code>httpclientmock&lt;/code> to test the integration&lt;/a>.&lt;/p>
&lt;h2 id="going-solo">Going Solo&lt;/h2>
&lt;p>Of course, you don&amp;rsquo;t need to use a custom library for testing. As long as you can create your own &lt;code>http.RoundTripper&lt;/code> (with some assertions about a request and the building of a response) and pass that to the &lt;code>http.Client&lt;/code> you are using, you&amp;rsquo;ll be fine.&lt;/p>
&lt;h1 id="the-business-answer">The Business Answer&lt;/h1>
&lt;p>Now, all good so far? Well, not so fast! As you know, we are in the real world trying to bring value to our business partners. And they don&amp;rsquo;t care as much about in-memory deterministic testing or testing theory or stuff like that. They want to know the answer to one single and simple question: &lt;strong>will this integration work for the end user&lt;/strong>.&lt;/p>
&lt;p>User Acceptance Testing (or UAT) tries to answer that question, and it is a freaking art. This is one of the most difficult tests to automate. We cannot use the tests suites we wrote because we are testing conformity to a spec, remember? Those tests cannot tell us if the integration will work, which is the purpose of UAT.&lt;/p>
&lt;p>UAT tests deserve a test suite of their own, usually excluded from running in the normal CI process. They should be run prior to a deployment (usually against a release candidate version) against a real testing/staging environment. Is in this test scenario when it makes sense to hit a real server.&lt;/p>
&lt;p>Now, it is not as simple as write some logic and hit the server. It is more complex than that.&lt;/p>
&lt;p>You see, now we are dealing with all kind of side effects and statefulness. If we want to test an endpoint called &lt;code>GET /accounts/123&lt;/code> we need to make sure that the account with id &lt;code>123&lt;/code> exists in the system before doing that, so we probably need to call &lt;code>POST /accounts&lt;/code> first with some payload. In almost every UAT test there are some calls that depend on state obtained by other calls. For this reason, UAT test suites usually involve a &lt;em>journey&lt;/em>. They test a complete flow, from start to finish. They are not isolated tests like your normal Unit Tests. You&amp;rsquo;ll find yourself doing calls, retrieving state and then using that state to do some more calls that will continue to change the state of a server.&lt;/p>
&lt;p>Of course, I don&amp;rsquo;t have to mention that this could fail at any point of the journey for some weird reason.&lt;/p>
&lt;p>Another thing I&amp;rsquo;ve found to be really complex is that environment statefulness makes it really hard to reuse any kind of identifier, because you want to make sure that the test starts with a clean slate every time and you don&amp;rsquo;t know if the third party service testing environment you are using cleans up every day.&lt;/p>
&lt;p>Due to their messiness and complexity of implementing them automatically, UAT testing is usually done manually, but this is very prone to errors. At the end of the day, all depends on how complex is the integration you are building. You are in a lucky position if most of the calls of your third party service are idempotent, for example.&lt;/p>
&lt;hr>
&lt;p>These are just some of my ideas, beliefs and past experiences with testing. I hope they can make some sense for you and that will guide you to take the best approach you can to test your integrations in Golang.&lt;/p></content></item><item><title>Implementing count endpoints using semantic HTTP</title><link>https://mnavarro.dev/posts/semantic-http-count-endpoints/</link><pubDate>Thu, 15 Oct 2020 01:00:00 +0100</pubDate><guid>https://mnavarro.dev/posts/semantic-http-count-endpoints/</guid><description>The HTTP protocol, the REST architectural pattern and API design are amongst my favorite topics in software development. I closely follow the latest RFCs, technologies and standards built over these, and over the years I&amp;rsquo;ve learned how not to repeat the mistakes of the past by improving the way I used to to things.
Count functionality implemented in a poor way is one of those mistakes. Back in the day I would have my api resources implement a count endpoint like this: GET /some-resource/count.</description><content>&lt;p>The HTTP protocol, the REST architectural pattern and API design are amongst my favorite topics in software development. I closely follow the latest RFCs, technologies and standards built over these, and over the years I&amp;rsquo;ve learned how not to repeat the mistakes of the past by improving the way I used to to things.&lt;/p>
&lt;p>Count functionality implemented in a poor way is one of those mistakes. Back in the day I would have my api resources implement a count endpoint like this: &lt;code>GET /some-resource/count&lt;/code>. This would return a json along these lines:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-json" data-lang="json">{
&lt;span style="color:#f92672">&amp;#34;count&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">3253&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The problem with this approach is manyfold. I&amp;rsquo;ll point the issues and explain why this is not a good idea, and then I will propose an alternative approach.&lt;/p>
&lt;h2 id="its-harder-to-maintain">It&amp;rsquo;s Harder to Maintain&lt;/h2>
&lt;p>If you define count as an endpoint, you have to implement the handler for that endpoint explicitly for every resource. (This unless you are creating your apis with schema definitions and code generation tools).&lt;/p>
&lt;p>In PHP, would look something like this:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-php" data-lang="php">&lt;span style="color:#75715e">&amp;lt;?php&lt;/span>
$router&lt;span style="color:#f92672">-&amp;gt;&lt;/span>&lt;span style="color:#a6e22e">nested&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;/users&amp;#39;&lt;/span>, &lt;span style="color:#66d9ef">function&lt;/span> ($router) {
$router&lt;span style="color:#f92672">-&amp;gt;&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;/&amp;#39;&lt;/span>, &lt;span style="color:#a6e22e">indexUsers&lt;/span>());
$router&lt;span style="color:#f92672">-&amp;gt;&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;/count&amp;#39;&lt;/span>, &lt;span style="color:#a6e22e">countUsers&lt;/span>());
$router&lt;span style="color:#f92672">-&amp;gt;&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;/:id&amp;#39;&lt;/span>, &lt;span style="color:#a6e22e">showUser&lt;/span>())
});
$router&lt;span style="color:#f92672">-&amp;gt;&lt;/span>&lt;span style="color:#a6e22e">nested&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;/likes&amp;#39;&lt;/span>, &lt;span style="color:#66d9ef">function&lt;/span> ($router) {
$router&lt;span style="color:#f92672">-&amp;gt;&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;/&amp;#39;&lt;/span>, &lt;span style="color:#a6e22e">indexLikes&lt;/span>());
$router&lt;span style="color:#f92672">-&amp;gt;&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;/count&amp;#39;&lt;/span>, &lt;span style="color:#a6e22e">countLikes&lt;/span>());
$router&lt;span style="color:#f92672">-&amp;gt;&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;/:id&amp;#39;&lt;/span>, &lt;span style="color:#a6e22e">showLike&lt;/span>())
});
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Another downside of this, is that due to the way routing engines work, you need to define the &lt;code>/count&lt;/code> endpoint before the &lt;code>/:id&lt;/code>. Otherwise &lt;code>count&lt;/code> will match as a resource of users, probably giving you a 404. I&amp;rsquo;ve seen routing bugs like this more times that I would like to. Junior developers can spend hours on a bug like this trying to figure our why their routes don&amp;rsquo;t match.&lt;/p>
&lt;p>So for every time you implement a new resource, you must remember and implement their corresponding count also.&lt;/p>
&lt;h2 id="tends-to-duplication">Tends to duplication&lt;/h2>
&lt;p>If you are a good api developer, then you are building filtering logic using query params over your collection endpoint. In other words, you are doing &lt;code>GET /users?status=inactive&amp;amp;role=admin&lt;/code> instead of &lt;code>GET/users-inactive-and-admin&lt;/code>. The main benefit of this is composability, and also mental sanity. Query params can be composed together to form collections representations with different rules and filters, instead of binding a hard-coded, uncomposable route to yet another handler.&lt;/p>
&lt;p>Chances are you want your count endpoints to use that filtering logic too. If you are not a careful developer, you might be temped to just copy and paste the code that handles the query params into the count methods, making it harder to maintain. Kudos to you if you thought of extracting that to a separate method/service, but I would say that while you ara avoiding duplication, you are missing the larger picture: maybe the duplication is an indication that those two things should not be separated in the first place.&lt;/p>
&lt;h2 id="breaks-rest">Breaks REST&lt;/h2>
&lt;p>Even though is perfectly possible to implement count in the aforementioned way, that approach does not follow the REST standard. REST focuses on operations over resources. Resources can be represented inside a collection or as a single unit, but that representation must be consistent. Traditionally, this has been implemented in apis as &lt;code>GET /resource&lt;/code> for collections and &lt;code>GET /resource/identifier&lt;/code> for a single resource. &lt;code>GET /resource/count&lt;/code> gives the impression of a single resource with the identifier &lt;code>count&lt;/code>. But this &amp;ldquo;resource&amp;rdquo; is special: it does not return the same representation: just a number.&lt;/p>
&lt;p>&lt;strong>The truth is that a count is metadata about a collection of resources&lt;/strong>, so it should not be implemented at the path that traditionally has been used to define single resources. We have see that this can confuse the routing engine, but also a client of your api.&lt;/p>
&lt;h2 id="a-better-approach">A Better Approach&lt;/h2>
&lt;p>Let&amp;rsquo;s remember our use case. We want to count resources in a collection. Sometimes we would use filters to count them and we want the count to change on those filters. But we don&amp;rsquo;t want to use another endpoint because it&amp;rsquo;s cumbersome and leads to confusion. As we said, count is metadata of a collection so, why not put the count in the collection endpoint? Mmm&amp;hellip;will something like this work?&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-json" data-lang="json">{
&lt;span style="color:#f92672">&amp;#34;meta&amp;#34;&lt;/span>: [
&lt;span style="color:#e6db74">&amp;#34;count&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> &lt;span style="color:#ae81ff">13532&lt;/span>,
&lt;span style="color:#e6db74">&amp;#34;page&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> &lt;span style="color:#ae81ff">13&lt;/span>
],
&lt;span style="color:#f92672">&amp;#34;data&amp;#34;&lt;/span>: [
&lt;span style="color:#960050;background-color:#1e0010">...&lt;/span>
]
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This is better, but not ideal. What happens if I just need the count? How do I get rid of the unnecessary json rendering of the representation is that&amp;rsquo;s the case?&lt;/p>
&lt;p>Well, turns that we a bit of tweaking and some semantic HTTP we can do better. HTTP has an obscure verb that can help us here, a verb to return just the headers of a request, but not the body: &lt;strong>the &lt;code>HEAD&lt;/code> verb&lt;/strong>.&lt;/p>
&lt;p>By HTTP spec, &lt;code>HEAD&lt;/code> should not have a return body but must have the exact same headers than the normal &lt;code>GET&lt;/code> request. You would be happy to know that the most popular routing libraries match &lt;code>HEAD&lt;/code> requests to your &lt;code>GET&lt;/code> requests automatically for you. This is done in the &lt;a href="https://stackoverflow.com/questions/22118598/laravel-routes-gethead">Laravel Router&lt;/a> for example.&lt;/p>
&lt;p>So, what if we move the &lt;code>meta&lt;/code> object we defined in the json to the response headers? Is not that the purpose of the headers in HTTP, to serve as metadata? So, we can have a response like this:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-http" data-lang="http">&lt;span style="color:#66d9ef">HTTP&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">1.1&lt;/span> &lt;span style="color:#ae81ff">200&lt;/span> &lt;span style="color:#a6e22e">OK&lt;/span>
Date&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">Sun, 10 Oct 2010 23:26:07 GMT&lt;/span>
Server&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">Apache/2.2.8 (Ubuntu) mod_ssl/2.2.8 OpenSSL/0.9.8g&lt;/span>
Content-Type&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">application/json&lt;/span>
X-Total-Count&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">23432&lt;/span>
[
{
&lt;span style="color:#f92672">&amp;#34;id&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;some-id&amp;#34;&lt;/span>,
&lt;span style="color:#f92672">&amp;#34;name: &amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">some-name&amp;#34;&lt;/span>
},
{
&lt;span style="color:#960050;background-color:#1e0010">...&lt;/span>
}
]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We moved the array to the top level and move the metadata to the headers. Now, if we want just the count, we can simply do &lt;code>HEAD /users&lt;/code> and return just the headers, but not build a json body when the request method is &lt;code>HEAD&lt;/code>. You save a database call and a lot of transformation logic, and you still get your count. And you can use your regular query params to filter data over that endpoint.&lt;/p>
&lt;h2 id="extra-advice">Extra Advice&lt;/h2>
&lt;p>I like to separate my actual resources from the fact they are a paginatable and countable collection of things. So, I usually split my resource logic with my collection handling logic.&lt;/p>
&lt;p>My collection handling logic just uses a simple interface:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-php" data-lang="php">&lt;span style="color:#75715e">&amp;lt;?php&lt;/span>
&lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">Collection&lt;/span> {
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">count&lt;/span>()&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">int&lt;/span>;
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">slice&lt;/span>(&lt;span style="color:#a6e22e">int&lt;/span> $offset, &lt;span style="color:#a6e22e">int&lt;/span> $size)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">Collection&lt;/span>;
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">iterator&lt;/span>()&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">iterable&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>What is under this I don&amp;rsquo;t really care much and long as it gives me a total count, and I can slice it for pagination purposes and filter over it.&lt;/p>
&lt;p>Then, I have a single collection handler that, when passed a &lt;code>Collection&lt;/code> interface, is capable of counting, paginating and rendering the body using the iterator if necessary.&lt;/p>
&lt;hr>
&lt;p>Hope you liked this article and that you find it useful.&lt;/p></content></item></channel></rss>